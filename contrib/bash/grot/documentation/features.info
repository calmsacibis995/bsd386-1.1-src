This is Info file features.info, produced by Makeinfo-1.55 from the
input file features.texi.

This text is a cursory description of the features that are present in
the Bash shell.

Copyright (C) 1991 Free Software Foundation, Inc.

This file is part of GNU Bash, the Bourne Again SHell.

Bash is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

Bash is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with Bash; see the file COPYING.  If not, write to the Free
Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.


File: features.info,  Node: Top,  Next: Bourne Shell Features,  Prev: (DIR),  Up: (DIR)

Bash Features
*************

   Bash contains features that appear in other popular shells, and some
features that only appear in Bash.  Some of the shells that Bash has
borrowed concepts from are the Bourne Shell (`sh'), the Korn Shell
(`ksh'), and the C-shell (`csh' and its successor, `tcsh'). The
following menu breaks the features up into categories based upon which
one of these other shells inspired the feature.

* Menu:

* Bourne Shell Features::	Features originally found in the
				Bourne shell.

* T-Csh Features::		Features originally found in the
				Berkeley C-Shell.

* Korn Shell Features::		Features originally found in the Korn
				Shell.

* Bash Specific Features::	Features found only in the Bash Shell.

* Using History Interactively::	Chapter dealing with history expansion
				rules.

* Command Line Editing::	Chapter describing the command line
				editing features.

* Variable Index::		Quick reference helps you find the
				variable you want.

* Concept Index::		General index for this manual.


File: features.info,  Node: Bourne Shell Features,  Next: T-Csh Features,  Prev: Top,  Up: Top

Bourne Shell Style Features
***************************

   Bash is an acronym for Bourne Again SHell.  The Bourne shell is the
traditional Unix shell written by Stephen Bourne.  All of the Bourne
shell builtin commands are available in Bash, and the rules for
evaluation and quoting are taken from the Posix 1003 specification for
the `standard' Unix shell.

   The shell builtin control features are briefly discussed here.

* Menu:

* Looping Constructs::		Shell commands for iterative action.
* Conditional Constructs::	Shell commands for conditional execution.


File: features.info,  Node: Looping Constructs,  Next: Conditional Constructs,  Up: Bourne Shell Features

Looping Constructs
==================

   Note that wherever you see an `;' in the description of a command's
syntax, it can be replaced indiscriminately with newlines.

   Bash supports the following looping constructs.

`until'
     The syntax of the `until' command is:
          until TEST-COMMANDS; do CONSEQUENT-COMMANDS; done
     Execute CONSEQUENT-COMMANDS as long as the final command in
     TEST-COMMANDS has an exit status which is not zero.

`while'
     The syntax of the `while' command is:
          while TEST-COMMANDS; do CONSEQUENT-COMMANDS; done

     Execute CONSEQUENT-COMMANDS as long as the final command in
     TEST-COMMANDS has an exit status of zero.

`for'
     The syntax of the for command is:

          for NAME [in WORDS ...]; do COMMANDS; done
     Execute COMMANDS for each member in WORDS, with NAME bound to the
     current member.  If "`in WORDS'" is not present, "`in "$@"'" is
     assumed.


File: features.info,  Node: Conditional Constructs,  Prev: Looping Constructs,  Up: Bourne Shell Features

Conditional Constructs
======================

`if'
     The syntax of the `if' command is:

          if TEST-COMMANDS; then
            CONSEQUENT-COMMANDS;
          [else ALTERNATE-CONSEQUENTS;]
          fi

     Execute CONSEQUENT-COMMANDS only if the final command in
     TEST-COMMANDS has an exit status of zero.  If "`else
     ALTERNATE-CONSEQUENTS'" is present, and the final command in
     TEST-COMMANDS has a non-zero exit status, then execute
     ALTERNATE-CONSEQUENTS.

`case'
     The syntax of the `case' command is:

          `case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac'

     Selectively execute COMMANDS based upon WORD matching PATTERN.
     The ``|'' is used to separate multiple patterns.

     Here is an example using `case' in a script that could be used to
     describe an interesting feature of an animal:

          echo -n "Enter the name of an animal:"
          read ANIMAL
          echo -n "The $ANIMAL has "
          case $ANIMAL in
            horse | dog | cat) echo -n "four";;
            man | kangaroo ) echo -n "two";;
            *) echo -n "an unknown number of";;
          esac
          echo "legs."


File: features.info,  Node: T-Csh Features,  Next: Korn Shell Features,  Prev: Bourne Shell Features,  Up: Top

(T)C-Shell Style Features
*************************

   The C-Shell "`csh'" was created by Bill Joy at UC Berkeley.  It is
generally considered to have better features for interactive use than
the Bourne shell.  Some of the `csh' features present in Bash include
job control, history expansion, `protected' redirection, and several
variables for controlling the interactive behaviour of the shell (e.g.
`ignoreeof').

   For details on history expansion, *note Using History
Interactively::..

   Bash has tilde (~) expansion, similar, but not identical, to that of
`csh'.  The following table shows what unquoted words beginning with a
tilde expand to.

`~'
     The current value of `$HOME'.

`~/foo'
     `$HOME'/foo

`~fred/foo'
     The subdirectory `foo' of the home directory of the user named
     `fred'.

`~+/foo'
     `$PWD'/foo

`~-'
     `$OLDPWD'/foo

   Here is a list of the commands and variables whose meanings were
taken from `csh'.

`pushd'
          pushd [DIR | +N]

     Save the current directory on a list and then CD to DIR.  With no
     arguments, exchanges the top two directories.

    `+N'
          Brings the Nth directory to the top of the list by rotating.

    `DIR'
          Makes the current working directory be the top of the stack,
          and then cd's to DIR.  You can see the saved directory list
          with the `dirs' command.

`popd'
          popd [+N]

     Pops the directory stack, and cd's to the new top directory.  The
     elements are numbered from 0 starting at the first directory
     listed with `dirs'; i.e. `popd' is equivalent to `popd 0'.

`dirs'
          dirs
     Display the list of currently remembered directories.  Directories
     find their way onto the list with the `pushd' command; you can get
     back up through the list with the `popd' command.

`history'
          history [N] [ [-w -r] [FILENAME]]

     Display the history list with line numbers.  Lines listed with
     with a `*' have been modified.  Argument of N says to list only
     the last N lines.  Argument `-w' means write out the current
     history file.  `-r' means to read it instead.  If FILENAME is
     given, then use that file, else if `$HISTFILE' has a value, use
     that, else use `~/.bash_history'.

`ignoreeof'
     If this variable is set, it represents the number of consecutive
     `EOF's Bash will read before exiting.  By default, Bash will exit
     upon reading an `EOF' character.


File: features.info,  Node: Korn Shell Features,  Next: Bash Specific Features,  Prev: T-Csh Features,  Up: Top

Korn Shell Style Features
*************************

`fc'
          `fc [-e ENAME] [-nlr] [FIRST] [LAST]'
          `fc -s [PAT=REP] [COMMAND]'

     Fix Command.  In the first form, a range of commands from FIRST to
     LAST is selected from the history list.  FIRST and/or LAST may be
     specified as a string (to locate the most recent command beginning
     with that string) or as a number (an index into the history list,
     where a negative number is used as an offset from the current
     command number).  If LAST is not specified it is set to FIRST.  If
     FIRST is not specified it is set to the previous command for
     editing and -16 for listing.  If the `-l' flag is given, the
     commands are listed on standard output.  The `-n' flag suppresses
     the command numbers when listing.  The `-r' flag reverses the
     order of the listing.  Otherwise, the editor given by ENAME is
     invoked on a file containing those commands.  If ENAME is not
     given, the value of the following variable expansion is used:
     `${FCEDIT:-${EDITOR:-vi}'.  This says to use the value of the
     `FCEDIT' variable if set, or the value of the `EDITOR' variable if
     that is set, or `vi' if neither is set.  When editing is complete,
     the edited commands are echoed and executed.

     In the second form, COMMAND is re-executed after the substitution
     OLD=NEW is performed.

     A useful alias to use with the `fc' command is `r='fc -s'', so
     that typing `r cc' runs the last command beginning with `cc' and
     typing `r' re-executes the last command.

`typeset'
     The `typeset' command is supplied for compatibility with the Korn
     shell; however, it has been made obsolete by the presence of the
     `declare' command, documented with the Bash specific features.

`type'
     Bash's `type' command is a superset of the `type' found in Korn
     shells; *Note Bash Builtins:: for details.


File: features.info,  Node: Bash Specific Features,  Next: Using History Interactively,  Prev: Korn Shell Features,  Up: Top

Bash Specific Features
**********************

* Menu:

* Command Line Options::	Command line options that you can give
				to Bash.
* The Set Builtin::		This builtin is so overloaded it
				deserves its own section.
* Is This Shell Interactive?::	Determining the state of a running Bash.
* Printing a Prompt::		Controlling the PS1 string.
* Bash Startup Files::		When and how Bash executes scripts.
* Bash Builtins::		Table of builtins specific to Bash.
* Bash Variables::		List of variables that exist in Bash.


File: features.info,  Node: Command Line Options,  Next: The Set Builtin,  Up: Bash Specific Features

Shell Command Line Options
==========================

   Along with the single character shell command-line options (*Note
The Set Builtin::) there are several other options that you can use.
These options must appear on the command line before the single
character command options to be recognized.

`-norc'
     Don't load ~/.bashrc init file. (Default if shell name is `sh').

`-rcfile FILENAME'
     Load FILENAME init file (instead `~/.bashrc').

`-noprofile'
     Don't load `~/.bash_profile' (nor `/etc/profile').

`-version'
     Display the version number of this shell.

`-login'
     Make this shell act as if it were directly invoked from login.
     This is equivalent to "exec - bash" but can be issued from another
     shell, such as csh.  If you wanted to replace your current login
     shell with a bash login shell, you would say "exec bash -login".

`-nobraceexpansion'
     Do not perform curly brace expansion (foo{a,b} -> fooa foob).

`-nolinediting'
     Do not use the GNU Readline library to read interactive text lines.


File: features.info,  Node: The Set Builtin,  Next: Is This Shell Interactive?,  Prev: Command Line Options,  Up: Bash Specific Features

The Set Builtin
===============

   This builtin is so overloaded that it deserves its own section.  So
here it is.

`set'
          set [-aefhknotuvxldH] [ARG ...]

    `-a'
          Mark variables which are modified or created for export.

    `-e'
          Exit immediately if a command exits with a non-zero status.

    `-f'
          Disable file name generation (globbing).

    `-k'
          All keyword arguments are placed in the environment for a
          command, not just those that precede the command name.

    `-m'
          Job control is enabled.

    `-n'
          Read commands but do not execute them.

    `-o OPTION-NAME'
          Set the variable corresponding to OPTION-NAME:

         `allexport'
               same as -a.

         `braceexpand'
               the shell will perform brace expansion.

         `emacs'
               use an emacs-style line editing interface.

         `errexit'
               same as -e.

         `histexpand'
               same as -H.

         `ignoreeof'
               the shell will not exit upon reading EOF.

         `monitor'
               same as -m.

         `noclobber'
               disallow redirection to existing files.

         `noexec'
               same as -n.

         `noglob'
               same as -f.

         `nohash'
               same as -d.

         `notify'
               notify of job termination immediately.

         `nounset'
               same as -u.

         `verbose'
               same as -v.

         `vi'
               use a vi-style line editing interface.

         `xtrace'
               same as -x.

    `-t'
          Exit after reading and executing one command.

    `-u'
          Treat unset variables as an error when substituting.

    `-v'
          Print shell input lines as they are read.

    `-x'
          Print commands and their arguments as they are executed.

    `-l'
          Save and restore the binding of the NAME in a `for' command.

    `-d'
          Disable the hashing of commands that are looked up for
          execution.  Normally, commands are remembered in a hash
          table, and once found, do not have to be looked up again.

    `-H'
          Enable ! style history substitution.  This flag is on by
          default.

     Using `+' rather than `-' causes these flags to be turned off.
     The flags can also be used upon invocation of the shell.  The
     current set of flags may be found in `$-'.  The remaining ARGs are
     positional parameters and are assigned, in order, to `$1', `$2',
     .. `$9'.  If no ARGs are given, all shell variables are printed.


File: features.info,  Node: Is This Shell Interactive?,  Next: Printing a Prompt,  Prev: The Set Builtin,  Up: Bash Specific Features

Is This Shell Interactive?
==========================

   You may wish to determine within a startup script whether Bash is
running interactively or not.  To do this, you examine the variable
`$PS1'; it is unset in non-interactive shells, and set in interactive
shells.  Thus:

     if [ "$PS1" = "" ]; then
       echo "This shell is not interactive"
     else
       echo "This shell is interactive"
     fi

   You can ask an interactive Bash to not run your `~/.bashrc' file
with the `-norc' flag.  You can change the name of the `~/.bashrc' file
to any other file name with `-rcfile FILENAME'.  You can ask Bash to
not run your `~/.bash_profile' file with the `-noprofile' flag.


File: features.info,  Node: Printing a Prompt,  Next: Bash Startup Files,  Prev: Is This Shell Interactive?,  Up: Bash Specific Features

Controlling the Prompt
======================

   The value of the variable `$PROMPT_COMMAND' is examined just before
Bash prints each toplevel prompt.  If it is set and non-null, then the
value is executed just as if you had typed it on the command line.

   In addition, the following table describes the special characters
which can appear in the `PS1' variable:

`\t'
     the time.

`\d'
     the date.

`\n'
     CRLF.

`\s'
     the name of the shell.

`\w'
     the current working directory.

`\W'
     the last element of PWD.

`\u'
     your username.

`\h'
     the hostname.

`\#'
     the command number of this command.

`\!'
     the history number of this command.

`\<octal>'
     the character code in octal.

`\\'
     a backslash.


File: features.info,  Node: Bash Startup Files,  Next: Bash Builtins,  Prev: Printing a Prompt,  Up: Bash Specific Features

Bash Startup Files
==================

   When and how Bash executes `~/.bash_profile', `~/.bashrc', and
`~/.bash_logout'.

     For Login shells:
     
         On logging in:
            If `/etc/profile' exists, then source it.
     
            If `~/.bash_profile' exists, then source it,
               else if `~/.bash_login' exists, then source it,
                  else if `~/.profile' exists, then source it.
     
         On logging out:
            If `~/.bash_logout' exists, source it.
     
     For non-login interactive shells:
         On starting up:
            If `~/.bashrc' exists, then source it.
     
     For non-interactive shells:
         On starting up:
            If the environment variable `ENV' is non-null, source the
            file mentioned there.

   So, typically, your `~/.bash_profile' contains the line
     `if [ -f `~/.bashrc' ]; then source `~/.bashrc'; fi'

after (or before) any login specific initializations.


File: features.info,  Node: Bash Builtins,  Next: Bash Variables,  Prev: Bash Startup Files,  Up: Bash Specific Features

Bash Builtin Commands
=====================

`builtin'
          builtin [SHELL-BUILTIN [ARGS]]
     Run a shell builtin.  This is useful when you wish to rename a
     shell builtin to be a function, but need the functionality of the
     builtin within the function itself.

`declare'
          declare [-[frxi]] NAME[=VALUE]
     Declare variables and/or give them attributes.  If no NAMEs are
     given, then display the values of variables instead.  `-f' means to
     use function names only.  `-r' says to make NAMEs readonly.  `-x'
     says to make NAMEs export.  `-i' says that the variable is to be
     treated as an integer; arithmetic evaluation (see `let') will be
     done when the variable is assigned to.  Using `+' instead of `-'
     turns off the attribute instead.  When used in a function, makes
     NAMEs local, as with the `local' command.

`type'
          type [-all] [-type | -path] [NAME ...]
     For each NAME, indicate how it would be interpreted if used as a
     command name.

     If the `-type' flag is used, `type' returns a single word which is
     one of "alias", "function", "builtin", "file" or "", if NAME is an
     alias, shell function, shell builtin, disk file, or unfound,
     respectively.

     If the `-path' flag is used, `type' either returns the name of the
     disk file that would be exec'ed, or nothing if `-type' wouldn't
     return "file".

     If the `-all' flag is used, returns all of the places that contain
     an executable named FILE.  This includes aliases and functions, if
     and only if the `-path' flag is not also used.

`enable'
          enable [-n] [NAME ...]
     Enable and disable builtin shell commands.  This allows you to use
     a disk command which has the same name as a shell builtin.  If `-n'
     is used, the NAMEs become disabled.  Otherwise NAMEs are enabled.
     For example, to use the `test' found on your path instead of the
     shell builtin version, you type `enable -n test'.

`help'
          help [PATTERN]
     Display helpful information about builtin commands.  If PATTERN is
     specified, gives detailed help on all commands matching PATTERN,
     otherwise a list of the builtins is printed.

`command'
          command [COMMAND [ARGS ...]]
     Runs COMMAND with ARG ignoring shell functions.  If you have a
     shell function called `ls', and you wish to call the command `ls',
     you can say "command ls".

`hash'
          hash [-r] [NAME]
     For each NAME, the full pathname of the command is determined and
     remembered.  The `-r' option causes the shell to forget all
     remembered locations.  If no arguments are given, information
     about remembered commands is presented.

`local'
          local NAME[=VALUE]
     Create a local variable called NAME, and give it VALUE.  `local'
     can only be used within a function; it makes the variable NAME
     have a visible scope restricted to that function and its children.

`readonly'
          readonly [-f] [NAME ...]
     The given NAMEs are marked readonly and the values of these NAMEs
     may not be changed by subsequent assignment.  If the -f option is
     given, the functions corresponding to the NAMEs are so marked.  If
     no arguments are given, a list of all readonly names is printed.

`ulimit'
          ulimit [-acdmstfpn [limit]]
     Ulimit provides control over the resources available to processes
     started by the shell, on systems that allow such control.  If an
     option is given, it is interpreted as follows:
    `-a'
          all current limits are reported.

    `-c'
          the maximum size of core files created.

    `-d'
          the maximum size of a process's data segment.

    `-m'
          the maximum resident set size.

    `-s'
          the maximum stack size.

    `-t'
          the maximum amount of cpu time in seconds.

    `-f'
          the maximum size of files created by the shell.

    `-p'
          the pipe buffer size.

    `-n'
          the maximum number of open file descriptors.

     If LIMIT is given, it is the new value of the specified resource.
     Otherwise, the current value of the specified resource is printed.
     If no option is given, then `-f' is assumed.  Values are in 1k
     increments, except for `-t', which is in seconds, and `-p', which
     is in increments of 512 bytes.


File: features.info,  Node: Bash Variables,  Prev: Bash Builtins,  Up: Bash Specific Features

Bash Variables
==============

`history_control'
     Set to a value of "ignorespace", it means don't enter lines which
     begin with a SPC on the history list.  Set to a value of
     "ignoredups", it means don't enter lines which match the last
     entered line.  Unset, or any other value than those above mean to
     save all lines on the history list.

`HISTFILE'
     The name of the file that the command history is saved in.

`HISTSIZE'
     If set, this is the maximum number of commands to remember in the
     history.

`histchars'
     Up to three characters which control history expansion, quick
     substitution, and tokenization.  The first character is the
     "history-expansion-char", that is, the character which signifies
     the start of a history expansion, normally `!'.  The second
     character is the character which signifies `quick substitution'
     when seen as the first character on a line, normally `^'.  The
     optional third character is the character which signifies the
     remainder of the line is a comment, when found as the first
     character of a word, usually `#'.

`hostname_completion_file'
     Contains the name of a file in the same format as `/etc/hosts' that
     should be read when the shell needs to complete a hostname.  You
     can change the file interactively; the next time you want to
     complete a hostname Bash will add the contents of the new file to
     the already existing database.

`MAILCHECK'
     How often (in seconds) that the shell should check for mail in the
     file(s) specified in `MAILPATH'.

`MAILPATH'
     Colon separated list of pathnames to check for mail in.  You can
     also specify what message is printed by separating the pathname
     from the message with a `?'.  `$_' stands for the name of the
     current mailfile.  For example:

          MAILPATH='/usr/spool/mail/bfox?"You have mail":~/shell-mail?"$_ has mail!"'

`ignoreeof'
`IGNOREEOF'
     Controls the action of the shell on receipt of an `EOF' character
     as the sole input.  If set, then the value of it is the number of
     `EOF' characters that can be seen in a row as sole input characters
     before the shell will exit.  If the variable exists but does not
     have a numeric value (or has no value) then the default is 10.  if
     the variable does not exist, then `EOF' signifies the end of input
     to the shell.  This is only in effect for interactive shells.

`auto_resume'
     This variable controls how the shell interacts with the user and
     job control.  If this variable exists then single word simple
     commands without redirects are treated as candidates for resumption
     of an existing job.  There is no ambiguity allowed; if you have
     more than one job beginning with the string that you have typed,
     then the most recently accessed job will be selected.

`no_exit_on_failed_exec'
     If this variable exists, the shell will not exit in the case that
     it couldn't execute the file specified in the `exec' command.

`PROMPT_COMMAND'
     If present, this contains a string which is a command to execute
     before the printing of each toplevel prompt.

`nolinks'
     If present, says not to follow symbolic links when doing commands
     that change the current working directory.  By default, bash
     follows the logical chain of directories when performing `cd' type
     commands.

     For example, if `/usr/sys' is a link to `/usr/local/sys' then:

          cd /usr/sys; echo $PWD -> /usr/sys
          cd ..; pwd -> /usr

     If `nolinks' exists, then:

          cd /usr/sys; echo $PWD -> /usr/local/sys
          cd ..; pwd -> /usr/local


File: features.info,  Node: Using History Interactively,  Next: Command Line Editing,  Prev: Bash Specific Features,  Up: Top

Using History Interactively
***************************

   This chapter describes how to use the GNU History Library
interactively, from a user's standpoint.  It should be considered a
user's guide.  For information on using the GNU History Library in your
own programs, see the GNU Readline Library Manual.

* Menu:

* History Interaction::		What it feels like using History as a user.


File: features.info,  Node: History Interaction,  Up: Using History Interactively

History Interaction
===================

   The History library provides a history expansion feature that is
similar to the history expansion in Csh.  The following text describes
the sytax that you use to manipulate the history information.

   History expansion takes place in two parts.  The first is to
determine which line from the previous history should be used during
substitution.  The second is to select portions of that line for
inclusion into the current one.  The line selected from the previous
history is called the "event", and the portions of that line that are
acted upon are called "words".  The line is broken into words in the
same fashion that the Bash shell does, so that several English (or
Unix) words surrounded by quotes are considered as one word.

* Menu:

* Event Designators::	How to specify which history line to use.
* Word Designators::	Specifying which words are of interest.
* Modifiers::		Modifying the results of susbstitution.


File: features.info,  Node: Event Designators,  Next: Word Designators,  Up: History Interaction

Event Designators
-----------------

   An event designator is a reference to a command line entry in the
history list.

`!'
     Start a history subsititution, except when followed by a space,
     tab, or the end of the line... = or (.

`!!'
     Refer to the previous command.  This is a synonym for `!-1'.

`!n'
     Refer to command line N.

`!-n'
     Refer to the command line N lines back.

`!string'
     Refer to the most recent command starting with STRING.

`!?string'[`?']
     Refer to the most recent command containing STRING.


File: features.info,  Node: Word Designators,  Next: Modifiers,  Prev: Event Designators,  Up: History Interaction

Word Designators
----------------

   A : separates the event specification from the word designator.  It
can be omitted if the word designator begins with a ^, $, * or %.
Words are numbered from the beginning of the line, with the first word
being denoted by a 0 (zero).

`0 (zero)'
     The zero'th word.  For many applications, this is the command word.

`n'
     The N'th word.

`^'
     The first argument.  that is, word 1.

`$'
     The last argument.

`%'
     The word matched by the most recent `?string?' search.

`x-y'
     A range of words; `-Y' Abbreviates `0-Y'.

`*'
     All of the words, excepting the zero'th.  This is a synonym for
     `1-$'.  It is not an error to use * if there is just one word in
     the event.  The empty string is returned in that case.


File: features.info,  Node: Modifiers,  Prev: Word Designators,  Up: History Interaction

Modifiers
---------

   After the optional word designator, you can add a sequence of one or
more of the following modifiers, each preceded by a :.

`#'
     The entire command line typed so far.  This means the current
     command, not the previous command, so it really isn't a word
     designator, and doesn't belong in this section.

`h'
     Remove a trailing pathname component, leaving only the head.

`r'
     Remove a trailing suffix of the form `.'SUFFIX, leaving the
     basename.

`e'
     Remove all but the suffix.

`t'
     Remove all leading  pathname  components, leaving the tail.

`p'
     Print the new command but do not execute it.


File: features.info,  Node: Command Line Editing,  Next: Variable Index,  Prev: Using History Interactively,  Up: Top

Command Line Editing
********************

   This text describes GNU's command line editing interface.

* Menu:

* Introduction and Notation::	Notation used in this text.
* Readline Interaction::	The minimum set of commands for editing a line.
* Readline Init File::		Customizing Readline from a user's view.


File: features.info,  Node: Introduction and Notation,  Next: Readline Interaction,  Up: Command Line Editing

Introduction to Line Editing
============================

   The following paragraphs describe the notation we use to represent
keystrokes.

   The text C-k is read as `Control-K' and describes the character
produced when the Control key is depressed and the k key is struck.

   The text M-k is read as `Meta-K' and describes the character
produced when the meta key (if you have one) is depressed, and the k
key is struck.  If you do not have a meta key, the identical keystroke
can be generated by typing ESC first, and then typing k.  Either
process is known as "metafying" the k key.

   The text M-C-k is read as `Meta-Control-k' and describes the
character produced by "metafying" C-k.

   In addition, several keys have their own names.  Specifically, DEL,
ESC, LFD, SPC, RET, and TAB all stand for themselves when seen in this
text, or in an init file (*note Readline Init File::., for more info).


File: features.info,  Node: Readline Interaction,  Next: Readline Init File,  Prev: Introduction and Notation,  Up: Command Line Editing

Readline Interaction
====================

   Often during an interactive session you type in a long line of text,
only to notice that the first word on the line is misspelled.  The
Readline library gives you a set of commands for manipulating the text
as you type it in, allowing you to just fix your typo, and not forcing
you to retype the majority of the line.  Using these editing commands,
you move the cursor to the place that needs correction, and delete or
insert the text of the corrections.  Then, when you are satisfied with
the line, you simply press RETURN.  You do not have to be at the end of
the line to press RETURN; the entire line is accepted regardless of the
location of the cursor within the line.

* Menu:

* Readline Bare Essentials::	The least you need to know about Readline.
* Readline Movement Commands::	Moving about the input line.
* Readline Killing Commands::	How to delete text, and how to get it back!
* Readline Arguments::		Giving numeric arguments to commands.


File: features.info,  Node: Readline Bare Essentials,  Next: Readline Movement Commands,  Up: Readline Interaction

Readline Bare Essentials
------------------------

   In order to enter characters into the line, simply type them.  The
typed character appears where the cursor was, and then the cursor moves
one space to the right.  If you mistype a character, you can use DEL to
back up, and delete the mistyped character.

   Sometimes you may miss typing a character that you wanted to type,
and not notice your error until you have typed several other
characters.  In that case, you can type C-b to move the cursor to the
left, and then correct your mistake.  Aftwerwards, you can move the
cursor to the right with C-f.

   When you add text in the middle of a line, you will notice that
characters to the right of the cursor get `pushed over' to make room
for the text that you have inserted.  Likewise, when you delete text
behind the cursor, characters to the right of the cursor get `pulled
back' to fill in the blank space created by the removal of the text.  A
list of the basic bare essentials for editing the text of an input line
follows.

C-b
     Move back one character.

C-f
     Move forward one character.

DEL
     Delete the character to the left of the cursor.

C-d
     Delete the character underneath the cursor.

Printing characters
     Insert itself into the line at the cursor.

C-_
     Undo the last thing that you did.  You can undo all the way back
     to an empty line.


File: features.info,  Node: Readline Movement Commands,  Next: Readline Killing Commands,  Prev: Readline Bare Essentials,  Up: Readline Interaction

Readline Movement Commands
--------------------------

   The above table describes the most basic possible keystrokes that
you need in order to do editing of the input line.  For your
convenience, many other commands have been added in addition to C-b,
C-f, C-d, and DEL.  Here are some commands for moving more rapidly
about the line.

C-a
     Move to the start of the line.

C-e
     Move to the end of the line.

M-f
     Move forward a word.

M-b
     Move backward a word.

C-l
     Clear the screen, reprinting the current line at the top.

   Notice how C-f moves forward a character, while M-f moves forward a
word.  It is a loose convention that control keystrokes operate on
characters while meta keystrokes operate on words.


File: features.info,  Node: Readline Killing Commands,  Next: Readline Arguments,  Prev: Readline Movement Commands,  Up: Readline Interaction

Readline Killing Commands
-------------------------

   "Killing" text means to delete the text from the line, but to save
it away for later use, usually by "yanking" it back into the line.  If
the description for a command says that it `kills' text, then you can
be sure that you can get the text back in a different (or the same)
place later.

   Here is the list of commands for killing text.

C-k
     Kill the text from the current cursor position to the end of the
     line.

M-d
     Kill from the cursor to the end of the current word, or if between
     words, to the end of the next word.

M-DEL
     Kill from the cursor the start of the previous word, or if between
     words, to the start of the previous word.

C-w
     Kill from the cursor to the previous whitespace.  This is
     different than M-DEL because the word boundaries differ.

   And, here is how to "yank" the text back into the line.  Yanking is

C-y
     Yank the most recently killed text back into the buffer at the
     cursor.

M-y
     Rotate the kill-ring, and yank the new top.  You can only do this
     if the prior command is C-y or M-y.

   When you use a kill command, the text is saved in a "kill-ring".
Any number of consecutive kills save all of the killed text together, so
that when you yank it back, you get it in one clean sweep.  The kill
ring is not line specific; the text that you killed on a previously
typed line is available to be yanked back later, when you are typing
another line.


File: features.info,  Node: Readline Arguments,  Prev: Readline Killing Commands,  Up: Readline Interaction

Readline Arguments
------------------

   You can pass numeric arguments to Readline commands.  Sometimes the
argument acts as a repeat count, other times it is the sign of the
argument that is significant.  If you pass a negative argument to a
command which normally acts in a forward direction, that command will
act in a backward direction.  For example, to kill text back to the
start of the line, you might type M- C-k.

   The general way to pass numeric arguments to a command is to type
meta digits before the command.  If the first `digit' you type is a
minus sign (-), then the sign of the argument will be negative.  Once
you have typed one meta digit to get the argument started, you can type
the remainder of the digits, and then the command.  For example, to give
the C-d command an argument of 10, you could type M-1 0 C-d.


File: features.info,  Node: Readline Init File,  Prev: Readline Interaction,  Up: Command Line Editing

Readline Init File
==================

   Although the Readline library comes with a set of Emacs-like
keybindings, it is possible that you would like to use a different set
of keybindings.  You can customize programs that use Readline by putting
commands in an "init" file in your home directory.  The name of this
file is `~/.inputrc'.

   When a program which uses the Readline library starts up, the
`~/.inputrc' file is read, and the keybindings are set.

   In addition, the `C-x C-r' command re-reads this init file, thus
incorporating any changes that you might have made to it.

* Menu:

* Readline Init Syntax::	Syntax for the commands in `~/.inputrc'.
* Readline Vi Mode::		Switching to `vi' mode in Readline.


File: features.info,  Node: Readline Init Syntax,  Next: Readline Vi Mode,  Up: Readline Init File

Readline Init Syntax
--------------------

   There are only four constructs allowed in the `~/.inputrc' file:

Variable Settings
     You can change the state of a few variables in Readline.  You do
     this by using the `set' command within the init file.  Here is how
     you would specify that you wish to use Vi line editing commands:

          set editing-mode vi

     Right now, there are only a few variables which can be set; so few
     in fact, that we just iterate them here:

    `editing-mode'
          The `editing-mode' variable controls which editing mode you
          are using.  By default, GNU Readline starts up in Emacs
          editing mode, where the keystrokes are most similar to Emacs.
          This variable can either be set to `emacs' or `vi'.

    `horizontal-scroll-mode'
          This variable can either be set to `On' or `Off'.  Setting it
          to `On' means that the text of the lines that you edit will
          scroll horizontally on a single screen line when they are
          larger than the width of the screen, instead of wrapping onto
          a new screen line.  By default, this variable is set to `Off'.

    `mark-modified-lines'
          This variable when set to `On', says to display an asterisk
          (`*') at the starts of history lines which have been modified.
          This variable is off by default.

    `prefer-visible-bell'
          If this variable is set to `On' it means to use a visible
          bell if one is available, rather than simply ringing the
          terminal bell.  By default, the value is `Off'.

Key Bindings
     The syntax for controlling keybindings in the `~/.inputrc' file is
     simple.  First you have to know the name of the command that you
     want to change.  The following pages contain tables of the command
     name, the default keybinding, and a short description of what the
     command does.

     Once you know the name of the command, simply place the name of
     the key you wish to bind the command to, a colon, and then the
     name of the command on a line in the `~/.inputrc' file.  The name
     of the key can be expressed in different ways, depending on which
     is most comfortable for you.

    KEYNAME: FUNCTION-NAME or MACRO
          KEYNAME is the name of a key spelled out in English.  For
          example:
               Control-u: universal-argument
               Meta-Rubout: backward-kill-word
               Control-o: ">&output"

          In the above example, `C-u' is bound to the function
          `universal-argument', and `C-o' is bound to run the macro
          expressed on the right hand side (that is, to insert the text
          `>&output' into the line).

    "KEYSEQ": FUNCTION-NAME or MACRO
          KEYSEQ differs from KEYNAME above in that strings denoting an
          entire key sequence can be specified.  Simply place the key
          sequence in double quotes.  GNU Emacs style key escapes can
          be used, as in the following example:

               "\C-u": universal-argument
               "\C-x\C-r": re-read-init-file
               "\e[11~": "Function Key 1"

          In the above example, `C-u' is bound to the function
          `universal-argument' (just as it was in the first example),
          `C-x C-r' is bound to the function `re-read-init-file', and
          `ESC [ 1 1 ~' is bound to insert the text `Function Key 1'.

* Menu:

* Commands For Moving::		Moving about the line.
* Commands For History::	Getting at previous lines.
* Commands For Text::		Commands for changing text.
* Commands For Killing::	Commands for killing and yanking.
* Numeric Arguments::		Specifying numeric arguments, repeat counts.
* Commands For Completion::	Getting Readline to do the typing for you.
* Miscellaneous Commands::	Other miscillaneous commands.


File: features.info,  Node: Commands For Moving,  Next: Commands For History,  Up: Readline Init Syntax

Commands For Moving
...................

`beginning-of-line (C-a)'
     Move to the start of the current line.

`end-of-line (C-e)'
     Move to the end of the line.

`forward-char (C-f)'
     Move forward a character.

`backward-char (C-b)'
     Move back a character.

`forward-word (M-f)'
     Move forward to the end of the next word.

`backward-word (M-b)'
     Move back to the start of this, or the previous, word.

`clear-screen (C-l)'
     Clear the screen leaving the current line at the top of the screen.


File: features.info,  Node: Commands For History,  Next: Commands For Text,  Prev: Commands For Moving,  Up: Readline Init Syntax

Commands For Manipulating The History
.....................................

`accept-line (Newline, Return)'
     Accept the line regardless of where the cursor is.  If this line is
     non-empty, add it to the history list.  If this line was a history
     line, then restore the history line to its original state.

`previous-history (C-p)'
     Move `up' through the history list.

`next-history (C-n)'
     Move `down' through the history list.

`beginning-of-history (M-<)'
     Move to the first line in the history.

`end-of-history (M->)'
     Move to the end of the input history, i.e., the line you are
     entering!

`reverse-search-history (C-r)'
     Search backward starting at the current line and moving `up'
     through the history as necessary.  This is an incremental search.

`forward-search-history (C-s)'
     Search forward starting at the current line and moving `down'
     through the the history as neccessary.


File: features.info,  Node: Commands For Text,  Next: Commands For Killing,  Prev: Commands For History,  Up: Readline Init Syntax

Commands For Changing Text
..........................

`delete-char (C-d)'
     Delete the character under the cursor.  If the cursor is at the
     beginning of the line, and there are no characters in the line, and
     the last character typed was not C-d, then return EOF.

`backward-delete-char (Rubout)'
     Delete the character behind the cursor.  A numeric arg says to kill
     the characters instead of deleting them.

`quoted-insert (C-q, C-v)'
     Add the next character that you type to the line verbatim.  This is
     how to insert things like C-q for example.

`tab-insert (M-TAB)'
     Insert a tab character.

`self-insert (a, b, A, 1, !, ...)'
     Insert yourself.

`transpose-chars (C-t)'
     Drag the character before point forward over the character at
     point.  Point moves forward as well.  If point is at the end of
     the line, then transpose the two characters before point.
     Negative args don't work.

`transpose-words (M-t)'
     Drag the word behind the cursor past the word in front of the
     cursor moving the cursor over that word as well.

`upcase-word (M-u)'
     Uppercase the current (or following) word.  With a negative
     argument, do the previous word, but do not move point.

`downcase-word (M-l)'
     Lowercase the current (or following) word.  With a negative
     argument, do the previous word, but do not move point.

`capitalize-word (M-c)'
     Uppercase the current (or following) word.  With a negative
     argument, do the previous word, but do not move point.


File: features.info,  Node: Commands For Killing,  Next: Numeric Arguments,  Prev: Commands For Text,  Up: Readline Init Syntax

Killing And Yanking
...................

`kill-line (C-k)'
     Kill the text from the current cursor position to the end of the
     line.

`backward-kill-line ()'
     Kill backward to the beginning of the line.  This is normally
     unbound.

`kill-word (M-d)'
     Kill from the cursor to the end of the current word, or if between
     words, to the end of the next word.

`backward-kill-word (M-DEL)'
     Kill the word behind the cursor.

`unix-line-discard (C-u)'
     Do what C-u used to do in Unix line input.  We save the killed
     text on the kill-ring, though.

`unix-word-rubout (C-w)'
     Do what C-w used to do in Unix line input.  The killed text is
     saved on the kill-ring.  This is different than backward-kill-word
     because the word boundaries differ.

`yank (C-y)'
     Yank the top of the kill ring into the buffer at point.

`yank-pop (M-y)'
     Rotate the kill-ring, and yank the new top.  You can only do this
     if the prior command is yank or yank-pop.


File: features.info,  Node: Numeric Arguments,  Next: Commands For Completion,  Prev: Commands For Killing,  Up: Readline Init Syntax

Specifying Numeric Arguments
............................

`digit-argument (M-0, M-1, ... M--)'
     Add this digit to the argument already accumulating, or start a new
     argument.  M- starts a negative argument.

`universal-argument ()'
     Do what C-u does in emacs.  By default, this is not bound.


File: features.info,  Node: Commands For Completion,  Next: Miscellaneous Commands,  Prev: Numeric Arguments,  Up: Readline Init Syntax

Letting Readline Type For You
.............................

`complete (TAB)'
     Attempt to do completion on the text before point.  This is
     implementation defined.  Generally, if you are typing a filename
     argument, you can do filename completion; if you are typing a
     command, you can do command completion, if you are typing in a
     symbol to GDB, you can do symbol name completion, if you are
     typing in a variable to Bash, you can do variable name
     completion...

`possible-completions (M-?)'
     List the possible completions of the text before point.


File: features.info,  Node: Miscellaneous Commands,  Prev: Commands For Completion,  Up: Readline Init Syntax

Some Miscellaneous Commands
...........................

`re-read-init-file (C-x C-r)'
     Read in the contents of your `~/.inputrc' file, and incorporate
     any bindings found there.

`abort (C-g)'
     Ding!  Stops things.

`do-uppercase-version (M-a, M-b, ...)'
     Run the command that is bound to your uppercase brother.

`prefix-meta (ESC)'
     Make the next character that you type be metafied.  This is for
     people without a meta key.  Typing `ESC f' is equivalent to typing
     `M-f'.

`undo (C-_)'
     Incremental undo, separately remembered for each line.

`revert-line (M-r)'
     Undo all changes made to this line.  This is like typing the `undo'
     command enough times to get back to the beginning.


File: features.info,  Node: Readline Vi Mode,  Prev: Readline Init Syntax,  Up: Readline Init File

Readline Vi Mode
----------------

   While the Readline library does not have a full set of Vi editing
functions, it does contain enough to allow simple editing of the line.

   In order to switch interactively between Emacs and Vi editing modes,
use the command M-C-j (toggle-editing-mode).

   When you enter a line in Vi mode, you are already placed in
`insertion' mode, as if you had typed an `i'.  Pressing ESC switches
you into `edit' mode, where you can edit the text of the line with the
standard Vi movement keys, move to previous history lines with `k', and
following lines with `j', and so forth.


File: features.info,  Node: Variable Index,  Next: Concept Index,  Prev: Command Line Editing,  Up: Top

Variable Index
**************

* Menu:

* auto_resume:                          Bash Variables.
* editing-mode:                         Readline Init Syntax.
* histchars:                            Bash Variables.
* HISTFILE:                             Bash Variables.
* history_control:                      Bash Variables.
* HISTSIZE:                             Bash Variables.
* horizontal-scroll-mode:               Readline Init Syntax.
* hostname_completion_file:             Bash Variables.
* IGNOREEOF:                            Bash Variables.
* ignoreeof:                            Bash Variables.
* MAILCHECK:                            Bash Variables.
* MAILPATH:                             Bash Variables.
* mark-modified-lines:                  Readline Init Syntax.
* nolinks:                              Bash Variables.
* no_exit_on_failed_exec:               Bash Variables.
* prefer-visible-bell:                  Readline Init Syntax.
* PROMPT_COMMAND:                       Bash Variables.


File: features.info,  Node: Concept Index,  Prev: Variable Index,  Up: Top

Concept Index
*************

* Menu:

* abort (C-g):                          Miscellaneous Commands.
* accept-line (Newline, Return):        Commands For History.
* backward-char (C-b):                  Commands For Moving.
* backward-delete-char (Rubout):        Commands For Text.
* backward-kill-line ():                Commands For Killing.
* backward-kill-word (M-DEL):           Commands For Killing.
* backward-word (M-b):                  Commands For Moving.
* beginning-of-history (M-<):           Commands For History.
* beginning-of-line (C-a):              Commands For Moving.
* builtin:                              Bash Builtins.
* capitalize-word (M-c):                Commands For Text.
* case:                                 Conditional Constructs.
* clear-screen (C-l):                   Commands For Moving.
* command:                              Bash Builtins.
* complete (TAB):                       Commands For Completion.
* declare:                              Bash Builtins.
* delete-char (C-d):                    Commands For Text.
* digit-argument (M-0, M-1, ... M-):    Numeric Arguments.
* dirs:                                 T-Csh Features.
* do-uppercase-version (M-a, M-b, ...): Miscellaneous Commands.
* downcase-word (M-l):                  Commands For Text.
* enable:                               Bash Builtins.
* end-of-history (M->):                 Commands For History.
* end-of-line (C-e):                    Commands For Moving.
* event designators:                    Event Designators.
* expansion:                            History Interaction.
* fc:                                   Korn Shell Features.
* for:                                  Looping Constructs.
* forward-char (C-f):                   Commands For Moving.
* forward-search-history (C-s):         Commands For History.
* forward-word (M-f):                   Commands For Moving.
* hash:                                 Bash Builtins.
* help:                                 Bash Builtins.
* history:                              T-Csh Features.
* History, how to use:                  Bash Variables.
* if:                                   Conditional Constructs.
* ignoreeof:                            T-Csh Features.
* interaction, readline:                Readline Interaction.
* kill-line (C-k):                      Commands For Killing.
* kill-word (M-d):                      Commands For Killing.
* local:                                Bash Builtins.
* next-history (C-n):                   Commands For History.
* popd:                                 T-Csh Features.
* possible-completions (M-?):           Commands For Completion.
* prefix-meta (ESC):                    Miscellaneous Commands.
* previous-history (C-p):               Commands For History.
* pushd:                                T-Csh Features.
* quoted-insert (C-q, C-v):             Commands For Text.
* re-read-init-file (C-x C-r):          Miscellaneous Commands.
* Readline, how to use:                 Modifiers.
* readonly:                             Bash Builtins.
* reverse-search-history (C-r):         Commands For History.
* revert-line (M-r):                    Miscellaneous Commands.
* self-insert (a, b, A, 1, !, ...):     Commands For Text.
* set:                                  The Set Builtin.
* tab-insert (M-TAB):                   Commands For Text.
* transpose-chars (C-t):                Commands For Text.
* transpose-words (M-t):                Commands For Text.
* type:                                 Korn Shell Features.
* type:                                 Bash Builtins.
* typeset:                              Korn Shell Features.
* ulimit:                               Bash Builtins.
* undo (C-_):                           Miscellaneous Commands.
* universal-argument ():                Numeric Arguments.
* unix-line-discard (C-u):              Commands For Killing.
* unix-word-rubout (C-w):               Commands For Killing.
* until:                                Looping Constructs.
* upcase-word (M-u):                    Commands For Text.
* while:                                Looping Constructs.
* yank (C-y):                           Commands For Killing.
* yank-pop (M-y):                       Commands For Killing.



Tag Table:
Node: Top929
Node: Bourne Shell Features2043
Node: Looping Constructs2708
Node: Conditional Constructs3752
Node: T-Csh Features5031
Node: Korn Shell Features7603
Node: Bash Specific Features9651
Node: Command Line Options10293
Node: The Set Builtin11448
Node: Is This Shell Interactive?14233
Node: Printing a Prompt15055
Node: Bash Startup Files15948
Node: Bash Builtins17040
Node: Bash Variables21531
Node: Using History Interactively25305
Node: History Interaction25823
Node: Event Designators26876
Node: Word Designators27520
Node: Modifiers28421
Node: Command Line Editing29171
Node: Introduction and Notation29603
Node: Readline Interaction30625
Node: Readline Bare Essentials31764
Node: Readline Movement Commands33272
Node: Readline Killing Commands34163
Node: Readline Arguments35803
Node: Readline Init File36754
Node: Readline Init Syntax37582
Node: Commands For Moving41529
Node: Commands For History42154
Node: Commands For Text43229
Node: Commands For Killing44896
Node: Numeric Arguments46023
Node: Commands For Completion46466
Node: Miscellaneous Commands47190
Node: Readline Vi Mode48032
Node: Variable Index48744
Node: Concept Index49868

End Tag Table
