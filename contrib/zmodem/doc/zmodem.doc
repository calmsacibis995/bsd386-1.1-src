


	   The ZMODEM Inter Application	File Transfer Protocol

			      Chuck Forsberg

			   Omen	Technology Inc


		    Copyright 1990 Omen	Technology INC
			   All Rights Reserved





		       Omen Technology Incorporated
		      The High Reliability Software

		   17505-V Northwest Sauvie Island Road
			  Portland Oregon 97231
			VOICE: 503-621-3406 :VOICE
	  Modem: 503-621-3746 Speed 1200,2400,19200(Telebit PEP)
		     Compuserve:70007,2304  GEnie:CAF
		    UUCP: ...!tektronix!reed!omen!caf



































Chapter	0	      Rev Sep-03-90  Typeset 9-7-90			 1







Chapter	0		     ZMODEM Protocol				 2



1.  IINNTTEENNDDEEDD AAUUDDIIEENNCCEE

This document is intended for telecommunications managers, systems
programmers, and others	who choose and implement asynchronous file
transfer protocols over	dial-up	networks and related environments.

This document covers the technical details of the public domain	ZMODEM
protocol.  It does not cover copyrighted Extensions thereto.


2.  WWHHYY	DDEEVVEELLOOPP	ZZMMOODDEEMM??

Since its development half a decade ago, the Ward Christensen MMOODDEEMM
protocol has enabled a wide variety of computer	systems	to interchange
data.  There is	hardly a communications	program	that doesn't at	least
claim to support this protocol,	now called XXMMOODDEEMM.

Advances in computing, modems and networking have spread the XMODEM
protocol far beyond the	micro to micro environment for which it	was
designed.  These application have exposed some weaknesses:

   o+ The awkward user interface	is suitable for	computer hobbyists.
     Multiple commands must be keyboarded to transfer each file.

   o+ Since commands must be given to both programs, simple menu	selections
     are not possible.

   o+ The short block length causes throughput to suffer	when used with
     timesharing systems, packet switched networks, satellite circuits,
     and buffered (error correcting) modems.

   o+ The 8 bit checksum	and unprotected	supervison allow undetected errors
     and disrupted file	transfers.

   o+ Only one file can be sent per command.  The file name has to be given
     twice, first to the sending program and then again	to the receiving
     program.

   o+ The transmitted file accumulates as many as 127 bytes of garbage.

   o+ The modification date and other file attributes are lost.

   o+ XMODEM requires _c_o_m_p_l_e_t_e 8	bit transparency, all 256 codes.  XMODEM
     will not operate over some	networks that use ASCII	flow control or
     escape codes.  Setting network transparency disables important
     control functions for the duration	of the call.

A number of other protocols have been developed	over the years,	but none
have proven satisfactory.





Chapter	2	      Rev Sep-03-90  Typeset 9-7-90			 2







Chapter	2		     ZMODEM Protocol				 3



   o+ Lack of public domain documentation and example programs have kept
     proprietary protocols such	as RReellaayy,, BBllaasstt,, DDAARRTT,, and others tightly
     bound to the fortunes of their suppliers.	These protocols	have not
     benefited from public scrutiny of their design features.

   o+ Link level	protocols such as XX..2255,,	XX..PPCC,, and MMNNPP do not manage
     application to application	file transfers.

   o+ Link Level	protocols do not eliminate end-to-end errors.  Interfaces
     between error-free	networks are not necessarily error-free.
     Sometimes,	error-free networks aren't.

   o+ The KKeerrmmiitt	protocol was developed to allow	file transfers in
     environments hostile to XMODEM.  The performance compromises
     necessary to accommodate traditional mainframe environments limit
     Kermit's efficiency.  Even	with completely	transparent channels,
     Kermit control character quoting limits the efficiency of binary file
     transfers to about	75 per cent.[1]

     A number of submodes are used in various Kermit programs, including
     different methods of transferring binary files.  Two Kermit programs
     will mysteriously fail to operate with each other if the user has not
     correctly specified these submodes.

     Kermit Sliding Windows ("SuperKermit") improves throughput	over
     networks at the cost of increased complexity.  SuperKermit	requires
     full duplex communications	and the	ability	to check for the presence
     of	characters in the input	queue, precluding its implementation on
     some operating systems.

     SuperKermit state transitions are encoded in a special language
     "wart" which requires a C compiler.

     SuperKermit sends an ACK packet for each data packet of 96	bytes
     (fewer if control characters are present).	 This reduces throughput
     on	high speed modems, from	1350 to	177 characters per second in one
     test.










__________

 1. Some Kermit	programs support run length encoding.




Chapter	2	      Rev Sep-03-90  Typeset 9-7-90			 3







Chapter	2		     ZMODEM Protocol				 4



A number of extensions to the XMODEM protocol have been	made to	improve
performance and	(in some cases)	the user interface.  They provide useful
improvements in	some applications but not in others.  XMODEM's unprotected
control	messages compromise their reliability.	Complex	proprietary
techniques such	as CCyybbeerrnneettiicc DDaattaa RReeccoovveerryy((TTMM))[2] improve reliability,
but are	not universally	available.  Some of the	XMODEM mutant protocols
have significant design	flaws of their own.

 o+ XXMMOODDEEMM--kk uses 1024 byte blocks to reduce the	overhead from transmission
   delays by 87	per cent compared to XMODEM, but network delays	still
   degrade performance.	 Some networks cannot transmit 1024 byte packets
   without flow	control, which is difficult to apply without impairing the
   perfect transparency	required by XMODEM.  XMODEM-k adds garbage to
   received files.

 o+ YYMMOODDEEMM sends	the file name, file length, and	creation date at the
   beginning of	each file, and allows optional 1024 byte blocks	for
   improved throughput.	 The handling of files that are	not a multiple of
   1024	or 128 bytes is	awkward, especially if the file	length is not
   known in advance, or	changes	during transmission.  The large	number of
   non conforming and substandard programs claiming to support YMODEM
   further complicates its use.

 o+ YYMMOODDEEMM--gg provides efficient batch file transfers, preserving	exact file
   length and file modification	date.  YMODEM-g	is a modification to
   YMODEM wherein ACKs for data	blocks are not used.  YMODEM-g is
   essentially insensitive to network delays.  Because it does not support
   error recovery, YMODEM-g must be used hard wired or with a reliable
   link	level protocol.	 Successful application	at high	speed requires
   cafeful attention to	transparent flow control.  When	YMODEM-g detects a
   CRC error, data transfers are aborted.  YMODEM-g is easy to implement
   because it closely resembles	standard YMODEM-1k.

 o+ WWXXMMOODDEEMM,, SSEEAAlliinnkk,, and MMEEGGAAlliinnkk have applied a subset	of ZMODEM's
   techniques to "Classic XMODEM" to improve upon their	suppliers'
   previous offerings.	They provide good performance under ideal
   conditions.

Another	XMODEM "extension" is protocol cheating, such as Omen Technology's
OOvveerrTThhrruusstteerr((TTMM)) and OOvveerrTThhrruusstteerr IIII((TTMM)).  These improve XMODEM	throughput
under some conditions by compromising error recovery.

The ZMODEM Protocol corrects the weaknesses described above while
maintaining as much of XMODEM/CRC's simplicity and prior art as	possible.



__________

 2. Unique to DSZ, ZCOMM, Professional-YAM and PowerCom




Chapter	2	      Rev Sep-03-90  Typeset 9-7-90			 4







Chapter	2		     ZMODEM Protocol				 5



3.  ZZMMOODDEEMM PPrroottooccooll DDeessiiggnn CCrriitteerriiaa

The design of a	file transfer protocol is an engineering compromise
between	conflicting requirements:

3.1  EEaassee ooff UUssee

 o+ ZMODEM allows either	program	to initiate file transfers.

 o+ The sender can pass commands	and/or modifiers to the	receiving program.

 o+ File	names need be entered only once.

 o+ Menu	selections are supported.

 o+ Wild	Card names may be used with batch transfers.

 o+ Minimum keystrokes required to initiate transfers.

 o+ ZRQINIT frame sent by sending program can trigger automatic downloads.

 o+ ZMODEM can optionally step down to YMODEM if	the other end does not
   support ZMODEM.[1]

3.2  TThhrroouugghhppuutt

All file transfer protocols make tradeoffs between throughput,
reliability, universality, and complexity according to the technology and
knowledge base available to their designers.

In the design of ZMODEM, three applications deserve special attention.

  o+ Network applications with significant delays (relative to character
    transmission time) and low error rate

  o+ Timesharing	and buffered modem applications	with significant delays
    and	throughput that	is quickly degraded by reverse channel traffic.
    ZMODEM's economy of	reverse	channel	bandwidth allows modems	that
    dynamically	partition bandwidth between the	two directions to operate
    at optimal speeds.	Special	ZMODEM features	allow simple, efficient
    implementation on a	wide variety of	timesharing hosts.

  o+ Direct modem to modem communications with high error rate

Unlike Sliding Windows Kermit, ZMODEM is not optimized for optimum


__________

 1. Provided the transmission medium accommodates X/YMODEM.




Chapter	3	      Rev Sep-03-90  Typeset 9-7-90			 5







Chapter	3		     ZMODEM Protocol				 6



throughput when	error rate and delays are both high.  This tradeoff
markedly reduces code complexity and memory requirements.  ZMODEM
generally provides faster error	recovery than network compatible XMODEM
implementations.

In the absence of network delays, rapid	error recovery is possible, much
faster than MEGAlink and network compatible versions of	YMODEM and XMODEM.

File transfers begin immediately regardless of which program is	started
first, without the 10 second delay associated with XMODEM.


3.3  IInntteeggrriittyy aanndd RRoobbuussttnneessss

Once a ZMODEM session is begun,	aallll transactions are protected with 16 or
32 bit CRC.[2] Complex proprietary techniques such as Omen Technology's
CCyybbeerrnneettiicc DDaattaa	RReeccoovveerryy((TTMM))[3]	are not	needed for reliable transfers.
This complete protection of data and supervisory information accounts for
most of	ZMODEM's high reliability compared to XMODEM derived protocols
including WXMODEM, SEAlink, MEGAlink, etc.

An optional 32-bit CRC used as the frame check sequence	in ADCCP (ANSI
X3.66, also known as FIPS PUB 71 and FED-STD-1003, the U.S. versions of
CCITT's	X.25) is available.  The 32 bit	CRC reduces undetected errors by
at least five orders of	magnitude when properly	applied	(-1 preset,
inversion).  32	bit CRC	is considered mandatory	for high speed and/or high
volume transfers of sensitive data.

A security challenge mechanism guards against "Trojan Horse" messages
written	to mimic legitimate command or file downloads.

3.4  EEaassee ooff IImmpplleemmeennttaattiioonn

ZMODEM accommodates a wide variety of systems:

 o+ Microcomputers that cannot overlap disk and serial i/o

 o+ Microcomputers that cannot overlap serial send and receive

 o+ Computers and/or networks requiring XON/XOFF	flow control




__________

 2. Except for the CAN-CAN-CAN-CAN-CAN abort sequence which requires five
    _s_u_c_c_e_s_s_i_v_e CAN characters.

 3. Unique to Professional-YAM,	ZCOMM, and PowerCom




Chapter	3	      Rev Sep-03-90  Typeset 9-7-90			 6







Chapter	3		     ZMODEM Protocol				 7



 o+ Computers that cannot check the serial input	queue for the presence of
   data	without	having to wait for the data to arrive.

Although ZMODEM	provides "hooks" for multiple "threads", ZMODEM	is not
intended to replace link level protocols such as X.25.

ZMODEM accommodates network and	timesharing system delays by continuously
transmitting data unless the receiver interrupts the sender to request
retransmission of garbled data.	 ZMODEM	in effect uses the entire file as
a window.[4] Using the entire file as a	window simplifies buffer
management, avoiding the window	overrun	failure	modes that affect
MEGAlink, SuperKermit, and others.

ZMODEM provides	a general purpose application to application file transfer
protocol which may be used directly or with with reliable link level
protocols such as X.25,	MNP, Fastlink, etc.  When used with X.25, MNP,
Fastlink, etc.,	ZMODEM detects and corrects errors in the interfaces
between	error controlled media and the remainder of the	communications
link.

ZMODEM was developed _f_o_r _t_h_e _p_u_b_l_i_c _d_o_m_a_i_n under a Telenet contract.  The
ZMODEM protocol	descriptions are public	domain.	 No licensing, trademark,
or copyright restrictions apply	to the use of the protocol and the _Z_M_O_D_E_M
name.


4.  EEVVOOLLUUTTIIOONN OOFF ZZMMOODDEEMM

In early 1986, Telenet funded a	project	to develop an improved public
domain application to application file transfer	protocol.  This	protocol
would alleviate	the throughput problems	network	customers were
experiencing with XMODEM and Kermit file transfers.

In the beginning, we thought a few modifications to XMODEM would allow
high performance over packet switched networks while preserving	XMODEM's
simplicity.

The initial concept would add a	block number to	the ACK	and NAK	characters
used by	XMODEM.	 The resultant protocol	would allow the	sender to send
more than one block before waiting for a response.

But how	to add the block number	to XMODEM's ACK	and NAK?  WXMODEM,
SEAlink, MEGAlink and some other protocols add binary byte(s) to indicate
the block number.



__________

 4. Streaming strategies are discussed in coming chapters.




Chapter	4	      Rev Sep-03-90  Typeset 9-7-90			 7







Chapter	4		     ZMODEM Protocol				 8



Pure binary was	unsuitable for ZMODEM because binary code combinations
won't pass bidirectionally through some	modems,	networks and operating
systems.  Other	operating systems may not be able to recognize something
coming back[1] unless a	break signal or	a system dependent code	or
sequence is present.  By the time all this and other problems with the
simple ACK/NAK sequences mentioned above were corrected, XMODEM's simple
ACK and	NACK characters	had evolved into a real	packet.	 The Frog was
riveting.

Managing the window[2] was another problem.  Experience	gained in
debugging The Source's SuperKermit protocol indicated a	window size of
about 1000 characters was needed at 1200 bps.  High speed modems require a
window of 20000	or more	characters for full throughput.	 Much of the
SuperKermit's inefficiency, complexity and debugging time centered around
its ring buffering and window management.  There had to	be a better way	to
get the	job done.

A sore point with XMODEM and its progeny is error recovery.  More to the
point, how can the receiver determine whether the sender has responded,	or
is ready to respond, to	a retransmission request?  XMODEM attacks the
problem	by throwing away characters until a certain period of silence.
Too short a time allows	a spurious pause in output (network or timesharing
congestion) to masquerade as error recovery.  Too long a timeout
devastates throughput, and allows a noisy line to lock up the protocol.
SuperKermit solves the problem with a distinct start of	packet character
(SOH).	WXMODEM	and ZMODEM use unique character	sequences to delineate the
start of frames.  SEAlink and MEGAlink do not address this problem.

A further error	recovery problem arises	in streaming protocols.	 How does
the receiver know when (or if) the sender has recognized its error signal?
Is the next packet the correct response	to the error signal?  Is it
something left over "in	the queue"?  Or	is this	new subpacket one of many
that will have to be discarded because the sender did not receive the
error signal?  How long	should this continue before sending another error
signal?	 How can the protocol prevent this from	degenerating into an
argument about mixed signals?

SuperKermit uses selective retransmission, so it can accept any	good
packet it receives.  Each time the SuperKermit receiver	gets a data
packet,	it must	decide which outstanding packet	(if any) it "wants most"
to receive, and	asks for that one.  In practice, complex software "hacks"
are needed to attain acceptable	robustness.[3]


__________

 1. Without stopping for a response

 2. The	WINDOW is the data in transit between sender and receiver.

 3. For	example, when SuperKermit encounters certain errors, the _w_n_d_e_s_r



Chapter	4	      Rev Sep-03-90  Typeset 9-7-90			 8







Chapter	4		     ZMODEM Protocol				 9



For ZMODEM, we decided to forgo	the complexity of SuperKermit's	packet
assembly scheme	and its	associated buffer management logic and memory
requirements.

Another	sore point with	XMODEM and WXMODEM is the garbage added	to files.
This was acceptable with the old CP/M files which had no exact length, but
not with newer systems such as PC-DOS and Unix.	 YMODEM	uses file length
information transmitted	in the header block to trim the	output file, but
this causes data loss when transferring	files that grow	during a transfer.
In some	cases, the file	length may be unknown, as when data is obtained
from a process.	 Variable length data subpackets solve both of these
problems.

Since some characters had to be	escaped	anyway,	there wasn't any point
wasting	bytes to fill out a fixed packet length	or to specify a	variable
packet length.	In ZMODEM, the length of data subpackets is denoted by
ending each subpacket with an escape sequence similar to BISYNC	and HDLC.

The end	result is a ZMOEM header containing a "frame type", four bytes of
supervisory information, and its own CRC.  Data	frames consist of a header
followed by 1 or more data subpackets.	In the absence of transmission
errors,	an entire file can be sent in one data frame.

Since the sending system may be	sensitive to numerous control characters
or strip parity	in the reverse data path, all of the headers sent by the
receiver are sent in hex.  A common lower level	routine	receives all
headers, allowing the main program logic to deal with headers and data
subpackets as objects.

With equivalent	binary (efficient) and hex (application	friendly) frame
headers, the sending program can send a	hex "invitation	to receive"
sequence to activate the receiver without crashing the remote application
with unexpected	control	characters.  ZMODEM's ability to accept	options
from both the sender and receiver further simplify application
development.

Going "back to scratch"	in the protocol	design presents	an opportunity to
steal good ideas from many sources and to add a	few new	ones.

From Kermit and	UUCP comes the concept of an initial dialog to exchange
system parameters.

ZMODEM generalizes Compuserve B	Protocol's host	controlled transfers to


__________________________________________________________________________

    function is	called to determine the	next block to request.	A burst	of
    errors generates several wasteful requests to retransmit the same
    block.




Chapter	4	      Rev Sep-03-90  Typeset 9-7-90			 9







Chapter	4		     ZMODEM Protocol				10



single command AutoDownload and	command	downloading.  A	Security Challenge
discourages password hackers and Trojan	Horse authors from abusing
ZMODEM's power.

We were	also keen to the pain and $uffering of legions of
telecommunicators whose	file transfers have been ruined	by communications
and timesharing	faults.	 ZMODEM's file transfer	recovery and advanced file
management are dedicated to these kindred comrades.

After ZMODEM had been operational a short time,	Earl Hall pointed out the
obvious: ZMODEM's user friendly	AutoDownload was almost	useless	if the
user must assign transfer options to each of the sending and receiving
programs.  Now,	transfer options may be	specified to/by	the sending
program, which passes them to the receiving program in the ZFILE header.


5.  RROOSSEETTTTAA SSTTOONNEE

Here are some definitions which	reflect	current	vernacular in the computer
media.	The attempt here is identify the file transfer protocol	rather
than specific programs.

XMODEM	refers to the original 1977 file transfer etiquette introduced by
	Ward Christensen's MODEM2 program.  It's also called the MODEM or
	MODEM2 protocol.  Some who are unaware of MODEM7's unusual batch
	file mode call it MODEM7.  Other aliases include "CP/M Users's
	Group" and "TERM II FTP	3".  This protocol is supported	by most
	communications programs	because	it is easy to implement.

XMODEM/CRC replaces XMODEM's 1 byte checksum with a two	byte Cyclical
	Redundancy Check (CRC-16), improving error detection.

XMODEM-1k Refers to XMODEM-CRC with optional 1024 byte blocks.

YMODEM	refers to the XMODEM/CRC protocol with batch transmission and
	optional 1024 byte blocks as described in YMODEM.DOC.

ZMODEM FRAME A ZMODEM frame consists of	a header and 0 or more data
	subpackets.

ZMODEM HEADER All ZMODEM headers contain a type	byte, header information,
	and CRC.

ZMODEM SUBPACKET A ZMODEM subpacket is a stream	of 0 to	1024 data bytes
	terminated by a	flag sequence and CRC.









Chapter	6	      Rev Sep-03-90  Typeset 9-7-90			10







Chapter	6		     ZMODEM Protocol				11



6.  ZZMMOODDEEMM RREEQQUUIIRREEMMEENNTTSS

Standard ZMODEM	requires an 8 bit transfer medium.[1] ZMODEM escapes
network	control	characters to allow operation with packet switched
networks.  In general, ZMODEM operates over any	path that supports XMODEM,
and over many that don't.

To support full	streaming,[2] the transmission path should either assert
flow control or	pass full speed	transmission without loss of data.
Otherwise the ZMODEM sender must manage	the window size.

6.1  FFiillee CCoonntteennttss

6.1.1  BBiinnaarryy FFiilleess
ZMODEM places no constraints on	the information	content	of binary files,
except that the	number of bits in the file must	be a multiple of 8.

6.1.2  TTeexxtt FFiilleess
When ZMODEM is used to transfer	files between different	types of computer
systems, text files must meet minimum requirements if they are to be
readable on a wide variety of systems and environments.

Text lines consist of printing ASCII characters, spaces, tabs, and
backspaces.

6.1.2.1	 AASSCCIIII EEnndd ooff LLiinnee
The ASCII code definition allows text lines terminated by a CR/LF (015,
012) sequence, or by a NL (012)	character.  Lines logically terminated by
a lone CR (013)	are not	ASCII text.

A CR (013) without a linefeed implies overprinting, and	is not acceptable
as a logical line separator.  Overprinted lines	should print all important
characters in the last pass to allow CRT displays to display meaningful
text.  Overstruck characters may be generated by backspacing or	by
overprinting the line with CR (015) not	followed by LF.

Overstruck characters generated	with backspaces	should be sent with the
most important character last to accommodate CRT displays that cannot
overstrike.  The sending program may use the ZZCCNNLL bit to force the
receiving program to convert the received end of line to its local end of
line convention.[3]


__________

 1. This document does not describe ZMODEM-90(TM) extensions for operation
    in 7 bit environments.

 2. With XOFF and XON, or out of band flow control such	as X.25	or CTS

 3. Files that have been translated in such a way as to	modify their



Chapter	6	      Rev Sep-03-90  Typeset 9-7-90			11







Chapter	6		     ZMODEM Protocol				12



7.  ZZMMOODDEEMM BBAASSIICCSS

7.1  PPaacckkeettiizzaattiioonn

ZMODEM frames differ somewhat from XMODEM blocks.  XMODEM blocks are not
used for the following reasons:

 o+ Block numbers are limited to	256

 o+ No provision	for variable length blocks

 o+ Line	hits corrupt protocol signals, causing failed file transfers.  In
   particular, modem errors sometimes generate false block numbers, false
   EOTs	and false ACKs.	 False ACKs are	the most troublesome as	they cause
   the sender to lose synchronization with the receiver.

   State of the	art programs such as Professional-YAM and ZCOMM	overcome
   some	of these weaknesses with clever	proprietary code, but a	stronger
   protocol is desired.

 o+ It is difficult to determine	the beginning and ends of XMODEM blocks
   when	line hits cause	a loss of synchronization.  This precludes rapid
   error recovery.

7.2  LLiinnkk EEssccaappee EEnnccooddiinngg

ZMODEM achieves	data transparency by extending the 8 bit character set
(256 codes) with escape	sequences based	on the ZMODEM data link	escape
character ZDLE.[1]

Link Escape coding permits variable length data	subpackets without the
overhead of a separate byte count.  It allows the beginning of frames to
be detected without special timing techniques, facilitating rapid error
recovery.

Link Escape coding does	add some overhead.  The	worst case, a file
consisting entirely of escaped characters, would incur a 50% overhead.

The ZDLE character is special.	ZDLE represents	a control sequence of some
sort.  If a ZDLE character appears in binary data, it is prefixed with
ZDLE, then sent	as ZDLEE.



__________________________________________________________________________

    length cannot be updated with the ZZCCRREECCOOVV Conversion Option.

 1. This and other constants are defined in the	_z_m_o_d_e_m._h include file.
    Please note	that constants with a leading 0	are octal constants in C.




Chapter	7	      Rev Sep-03-90  Typeset 9-7-90			12







Chapter	7		     ZMODEM Protocol				13



The value for ZDLE is octal 030	(ASCII CAN).  This particular value was
chosen to allow	a string of 5 consecutive CAN characters to abort a ZMODEM
session, compatible with YMODEM	session	abort.

Since CAN is not used in normal	terminal operations, interactive
applications and communications	programs can monitor the data flow for
ZDLE.  The following characters	can be scanned to detect the ZRQINIT
header,	the invitation to automatically	download commands or files.

Receipt	of five	successive CAN characters will abort a ZMODEM session.
Eight CAN characters are sent.

The receiving program decodes any sequence of ZDLE followed by a byte with
bit 6 set and bit 5 reset (upper case letter, either parity) to	the
equivalent control character by	inverting bit 6.  This allows the
transmitter to escape any control character that cannot	be sent	by the
communications medium.	In addition, the receiver recognizes escapes for
0177 and 0377 should these characters need to be escaped.

ZMODEM software	escapes	ZDLE, 020, 0220, 021, 0221, 023, and 0223.  If
preceded by 0100 or 0300 (@), 015 and 0215 are also escaped to protect the
Telenet	command	escape CR-@-CR.	 The receiver ignores 021, 0221, 023, and
0223 characters	in the data stream.[2]

The ZMODEM routines in zm.c accept an option to	escape all control
characters, to allow operation with less transparent networks.	This
option can be given to either the sending or receiving program.

7.3  HHeeaaddeerr

All ZMODEM frames begin	with a header which may	be sent	in binary or HEX
form.  ZMODEM uses a single routine to recognize binary	and hex	headers.
Either form of the header contains the same raw	information:

 o+ A type byte

 o+ Four	bytes of data indicating flags and/or numeric quantities depending
   on the frame	type









__________

 2. ZMODEM-90 extensions control the set of characters that are	escaped.




Chapter	7	      Rev Sep-03-90  Typeset 9-7-90			13







Chapter	7		     ZMODEM Protocol				14



		   FFiigguurree 11..  Order of Bytes in	Header

		   TYPE:  frame	type
		   F0: Flags least significant byte
		   P0: file Position least significant
		   P3: file Position most significant

			   TYPE	 F3 F2 F1 F0
			   -------------------
			   TYPE	 P0 P1 P2 P3

7.3.1  1166 BBiitt CCRRCC BBiinnaarryy HHeeaaddeerr
A binary header	is sent	by the sending program to the receiving	program.
ZDLE encoding accommodates XON/XOFF flow control.

A binary header	begins with the	sequence ZPAD, ZDLE, ZBIN.

The frame type byte is ZDLE encoded.

The four position/flags	bytes are ZDLE encoded.

A two byte CRC of the frame type and position/flag bytes is ZDLE encoded.

0 or more binary data subpackets with 16 bit CRC will follow depending on
the frame type.

The C function _z_s_b_h_d_r transmits	a binary header.  The C	function _z_g_e_t_h_d_r
receives a binary or hex header.

		   FFiigguurree 22..  16 Bit CRC Binary	Header
	   ZPAD	ZDLE A TYPE F3/P0 F2/P1	F1/P2 F0/P3 CRC-1 CRC-2


7.3.2  3322 BBiitt CCRRCC BBiinnaarryy HHeeaaddeerr
A "32 bit CRC" Binary header is	similar	to a Binary Header, except the
ZZBBIINN (A) character is replaced by a ZZBBIINN3322 (C) character, and four
characters of CRC are sent.  0 or more binary data subpackets with 32 bit
CRC will follow	depending on the frame type.


7.3.3  3322 BBiitt CCRRCC BBiinnaarryy HHeeaaddeerr	-- RRLLEE
A "32 bit CRC -	RLE" Binary header is similar to a Binary Header, except
the ZZBBIINN (A) character is replaced by a	ZZBBIINNRR3322	(D) character, and four
characters of CRC are sent.  0 or more RLE packed binary data subpackets
with 32	bit CRC	will follow depending on the frame type.

The common variable _T_x_f_c_s_3_2 may	be set TRUE for	32 bit CRC iff the
receiver indicates the capability with the CCAANNFFCC3322 bit.	 The zgethdr,
zsdata and zrdata C functions automatically adjust to the type of Frame





Chapter	7	      Rev Sep-03-90  Typeset 9-7-90			14







Chapter	7		     ZMODEM Protocol				15



Check Sequence being used.
		   FFiigguurree 33..  32 Bit CRC Binary	Header
     ZPAD ZDLE C TYPE F3/P0 F2/P1 F1/P2	F0/P3 CRC-1 CRC-2 CRC-3	CRC-4


7.3.4  HHEEXX HHeeaaddeerr
The receiver sends responses in	hex headers.  The sender also uses hex
headers	when they are not followed by binary data subpackets.

Hex encoding protects the reverse channel from random control characters.
The hex	header receiving routine ignores parity.[3]

Use of Kermit style encoding for control and paritied characters was
considered and rejected	because	of increased possibility of interacting
with some timesharing systems' line edit functions.  Use of HEX	headers
from the receiving program allows control characters to	be used	to
interrupt the sender when errors are detected.	A HEX header may be used
in place of a binary header wherever convenient.  If a data subpacket
follows	a HEX header, it is protected with CRC-16.

A hex header begins with the sequence ZPAD, ZPAD, ZDLE,	ZHEX.  The _z_g_e_t_h_d_r
routine	synchronizes with the ZPAD-ZDLE	sequence.  The extra ZPAD
character allows the sending program to	scan for a ZPAD	character, to
detect a header	(indicating an error condition)	and then call _z_g_e_t_h_d_r to
receive	the header.

The type byte, the four	position/flag bytes, and the 16	bit CRC	thereof
are sent in hex	using the character set	01234567890abcdef.  Upper case hex
digits are not allowed;	they false trigger XMODEM and YMODEM programs.

A carriage return and line feed	are sent with HEX headers.  The	receive
routine	expects	to see at least	one of these characters, two if	the first
is CR.

The receiver carefully checks hex headers for violations of this format.
Since the constraints and redundancy of	this hex encoding detect many
patterns of errors, especially missing characters, a hex header	with 32
bit CRC	has not	been defined.

The CR/LF aids debugging from printouts, and helps overcome certain
operating system related problems.  The	LF is sent with	8th bit	set to aid
the receiver in	checking for 7 bit paths.

An XON character is appended to	all HEX	headers	except ZACK and	ZFIN.  The
XON releases the sender	from spurious XOFF flow	control	characters


__________

 3. Except to detect the presence of a 7-bit transmission path.




Chapter	7	      Rev Sep-03-90  Typeset 9-7-90			15







Chapter	7		     ZMODEM Protocol				16



generated by line noise, a common occurrence.  XON is not sent after ZACK
headers	to protect flow	control	in streaming situations.  XON is not sent
after a	ZFIN header to allow clean session cleanup.  The receiver may or
may not	receive	the XON	character depending on the flow	control
arrangements.

0 or more data subpackets will follow depending	on the frame type.

The C function _z_s_h_h_d_r sends a hex header.

			  FFiigguurree 44..  HEX Header

 ZPAD ZPAD ZDLE	B TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2 CR LF+128 XON

(TYPE, F3...F0,	CRC-1, and CRC-2 are each sent as two hex digits.)


7.4  BBiinnaarryy DDaattaa SSuubbppaacckkeettss

Binary data subpackets immediately follow the associated binary	header
packet.	 A binary data subpacket contains 0 to 1024 bytes of data.
Recommended length values are 256 bytes	below 2400 bps,	512 at 2400 bps,
and 1024 above 4800 bps	or when	the data link is known to be relatively
error free.[4]

No padding is used with	binary data subpackets.	 The data bytes	are ZDLE
encoded	and transmitted.  A ZDLE and frameend are then sent, followed by
two or four ZDLE encoded CRC bytes.  The CRC accumulates the data bytes
and frameend.

The C function _z_s_d_a_t_a sends a data subpacket.  The C function _z_r_d_a_t_a
receives a data	subpacket.

7.5  RRLLEE BBiinnaarryy	DDaattaa SSuubbppaacckkeettss

Data subpackets	following a ZZBBIINNRR3322 header are run length encoded to
reduce transmission time on files with favorable characteristics.  Special
attention is paid to moderately	long runs of spaces commonly found in text
files.

The expression of RLE technology in ZMODEM is copyrighted by Omen
Technology Inc.	Licensing conditions are set forth in the source code.
Source code for	the RLE	routines is available from Omen	Technology INC.


__________

 4. Strategies for adjusting the subpacket length for optimal results
    based on real time error rates are still evolving.	Shorter	subpackets
    speed error	detection but increase protocol	overhead slightly.




Chapter	7	      Rev Sep-03-90  Typeset 9-7-90			16







Chapter	7		     ZMODEM Protocol				17



7.6  RRLLEE BBiinnaarryy	DDaattaa SSuubbppaacckkeettss	wwiitthh 88tthh BBiitt QQuuoottiinngg

A similar application of RLE encoding coupled with Kermit style	8th bit
quoting	is used	for data packets compatible with 7 bit transmission paths.
This is	a Copyrighted ZMODEM-90	extension available for	licensing from
Omen Technology	INC.

7.7  AASSCCIIII EEnnccooddeedd DDaattaa	SSuubbppaacckkeett

ASCII encoded packed data subpackets send 4 bytes of binary data in 5
bytes of printing characters.  This format is ideal for	sending	compressed
files over 7 bit paths.	 This is a Copyrighted ZMODEM-90 extension
available for licensing	from Omen Technology INC.


8.  PPRROOTTOOCCOOLL TTRRAANNSSAACCTTIIOONN OOVVEERRVVIIEEWW

As with	the XMODEM recommendation, ZMODEM timing is receiver driven.  The
transmitter should not time out	at all,	except to abort	the program if no
headers	are received for an extended period of time, say one minute.[1]

It goes	without	saying that both the transmitter and receiver should check
carrier	detect or equivalent signals often enough to properly exit in the
event of a disconnect.	Keep in	mind that in ZMODEM's most efficient mode
of operation, no response is expected from the receiver	during the entire
file transfer except for error correction!

8.1  SSeessssiioonn SSttaarrttuupp

To start a ZMODEM file transfer	session, the sending program is	called
with the names of the desired file(s) and option(s).

The sending program may	send the string	"rz\r" to invoke the receiving
program	from a possible	command	mode.  The "rz"	followed by carriage
return activates a ZMODEM receive program or command if	it were	not
already	active.

The sender may then display a message intended for human consumption, such
as a list of the files requested, etc.

Then the sender	sends a	ZZRRQQIINNIITT	header.	 The ZZRRQQIINNIITT header causes a
previously started receive program to send its ZZRRIINNIITT header without
delay.

In an interactive or conversational mode, the receiving	application may


__________

 1. Special considerations apply when sending commands.




Chapter	8	      Rev Sep-03-90  Typeset 9-7-90			17







Chapter	8		     ZMODEM Protocol				18



monitor	the data stream	for ZDLE.  The following characters may	be scanned
for BB0000	indicating a ZRQINIT header, a command to download a command or
data.

The sending program awaits a command from the receiving	program	to start
file transfers.	 If a "C", "G",	or NAK is received, an XMODEM or YMODEM
file transfer is indicated, and	file transfer(s) use the YMODEM
protocol.[2] Note: With	ZMODEM and YMODEM, the sending program provides
the file name, but not with XMODEM.

In case	of garbled data, the sending program can repeat	the invitation to
receive	a number of times until	a session starts.

When the ZMODEM	receive	program	starts,	it immediately sends a ZZRRIINNIITT
header to initiate ZMODEM file transfers, or a ZZCCHHAALLLLEENNGGEE header to verify
the sending program.  The receive program resends its header at	_r_e_s_p_o_n_s_e
_t_i_m_e (default 10 second) intervals for a suitable period of time (40
seconds	total) before falling back to YMODEM protocol.

If the receiving program receives a ZZRRQQIINNIITT header, it resends the ZZRRIINNIITT
header.	 If the	sending	program	receives the ZZCCHHAALLLLEENNGGEE	header,	it places
the data in ZP0...ZP3 in an answering ZZAACCKK header.

If the receiving program receives a ZZRRIINNIITT header, it is an echo
indicating that	the sending program is not operational.

Eventually the sending program correctly receives the ZZRRIINNIITT header.

The sender may then send an optional ZZSSIINNIITT frame to define the	receiving
program's AAttttnn sequence, or to specify complete	control	character
escaping.[3]

If the ZSINIT header specifies ESCCTL or ESC8, a HEX header is used, and
the receiver activates the specified ESC modes before reading the
following data subpacket.

The receiver sends a ZZAACCKK header in response, containing either	the serial
number of the receiving	program, or 0.





__________

 2. Allowing this fallback to XMODEM or	YMODEM compromises reliability and
    is not recommended as a default.

 3. If the receiver specifies the same or higher level of escaping, the
    ZSINIT frame need not be sent unless an Attn sequence is needed.




Chapter	8	      Rev Sep-03-90  Typeset 9-7-90			18







Chapter	8		     ZMODEM Protocol				19



8.2  FFiillee TTrraannssmmiissssiioonn

The sender then	sends a	ZZFFIILLEE header with ZMODEM Conversion, Management,
and Transport options[4] followed by a ZCRCW data subpacket containing the
file name, file	length,	modification date, and other information identical
to that	used by	YMODEM.

The receiver examines the file name, length, and date information provided
by the sender in the context of	the specified transfer options,	the
current	state of its file system(s), and local security	requirements.  The
receiving program should insure	the pathname and options are compatible
with its operating environment and local security requirements.

The receiver may respond with a	ZZSSKKIIPP header, which makes the sender
proceed	to the next file (if any) in the batch.

The receiver may respond with a	ZZFFEERRRR header, indicating an error in
attempting to open the file.  Possible errors include write protected
file, disk error, out of buffers.

       The receiver has	a file with the	same name and length, may
       respond with a ZZCCRRCC header with a byte count, which
       requires	the sender to perform a	32 bit CRC on the
       specified number	of bytes in the	file and transmit the
       complement of the CRC in	an answering ZZCCRRCC header.[5] The
       receiver	uses this information to determine whether to
       accept the file or skip it.  This sequence may be triggered
       by the ZMCRC Management Option.

A ZZRRPPOOSS	header from the	receiver initiates transmission	of the file data
starting at the	offset in the file specified in	the ZZRRPPOOSS header.
Normally the receiver specifies	the data transfer to begin begin at
offset 0 in the	file.
       The receiver may	start the transfer further down	in the
       file.[6]	This allows a file transfer interrupted	by a loss
       of carrier or system crash to be	completed on the next
       connection without requiring the	entire file to be


__________

 4. See	below, under ZFILE header type.

 5. The	crc is initialized to 0xFFFFFFFF.  A byte count	of 0 implies the
    entire file.

 6. The	sending	program's operating system file	structure may require this
    offset to be an integral multiple of the file system record	size.  A
    good rule of thumb is to round the offset down to the nearest multiple
    of 1024.




Chapter	8	      Rev Sep-03-90  Typeset 9-7-90			19







Chapter	8		     ZMODEM Protocol				20



       retransmitted.[7] If downloading	a file from a timesharing
       system that becomes sluggish, the transfer can be
       interrupted and resumed later with no loss of data.

The sender sends a ZZDDAATTAA binary	header (with file position) followed by
one or more data subpackets.

The receiver compares the file position	in the ZZDDAATTAA header with the
number of characters successfully received to the file.	 If they do not
agree, a ZZRRPPOOSS error response is generated to force the	sender start a
new frame at the correct position within the file.[8]

A data subpacket terminated by ZZCCRRCCGG and CRC does not elicit a response
unless an error	is detected; more data subpacket(s) follow immediately.

       ZZCCRRCCQQ data subpackets expect a ZZAACCKK response with the
       receiver's file offset if no error, otherwise a ZZRRPPOOSS
       response	with the last good file	offset.	 Another data
       subpacket continues immediately.	 ZZCCRRCCQQ subpackets are
       not used	if the receiver	does not indicate FDX ability
       with the	CCAANNFFDDXX bit.

ZZCCRRCCWW data subpackets expect a response	before the next	frame is sent.
If the receiver	does not indicate overlapped I/O capability with the
CCAANNOOVVIIOO	bit, or	sets a buffer size, the	sender uses the	ZZCCRRCCWW to allow
the receiver to	write its buffer before	sending	more data.

       A zero length data frame	may be used as an idle
       subpacket to prevent the	receiver from timing out in
       case data is not	immediately available to the sender.

In the absence of fatal	error, the sender eventually encounters	end of
file.  If the end of file is encountered within	a frame, the frame is
closed with a ZZCCRRCCEE data subpacket which does not elicit a response
except in case of error.

The sender sends a ZZEEOOFF	header with the	file ending offset equal to
the number of characters in the	file. [9] The receiver compares	this
number with the	number of characters received.	If this	comparision


__________

 7. This does not apply	to files that have been	translated.

 8. If the ZMSPARS option is used, the receiver	instead	seeks to the
    position given in the ZDATA	header.

 9. As determined by the offset	within the file	at the time the	sending
    program encountered	end-of-file.




Chapter	8	      Rev Sep-03-90  Typeset 9-7-90			20







Chapter	8		     ZMODEM Protocol				21



indicates the receiver has received all	of the file, the receiver
closes the file.  If the file close was	satisfactory, the receiver
responds with ZZRRIINNIITT.  If the receiver has not received	all the	bytes
of the file, the receiver ignores the ZEOF because a new ZDATA is
coming.	 If the	receiver cannot	properly close the file, a ZZFFEERRRR
header is sent.

       After all files are processed, any further protocol
       errors should not prevent the sending program from
       returning with a	success	status.


8.3  SSeessssiioonn CClleeaannuupp

The sender closes the session with a ZZFFIINN header.  The receiver
acknowledges this with its own ZZFFIINN header.

When the sender	receives the acknowledging header, it sends two
characters, "OO" (Over and Out)	and exits to the operating system or
application that invoked it.  The receiver waits briefly for the "O"
characters, then exits whether they were received or not.

8.4  SSeessssiioonn AAbboorrtt SSeeqquueennccee

If the receiver	is receiving data in streaming mode, the AAttttnn
sequence is executed to	interrupt data transmission before the Cancel
sequence is sent.  The Cancel sequence consists	of eight CAN
characters and ten backspace characters.  ZMODEM only requires five
Cancel characters, the other three are "insurance".

The trailing backspace characters attempt to erase the effects of the
CAN characters if they are received by a command interpreter.

       static char canistr[] = {
	24,24,24,24,24,24,24,24,8,8,8,8,8,8,8,8,8,8,0
       };


















Chapter	8	      Rev Sep-03-90  Typeset 9-7-90			21







Chapter	8		     ZMODEM Protocol				22



9.  SSTTRREEAAMMIINNGG TTEECCHHNNIIQQUUEESS // EERRRROORR RREECCOOVVEERRYY

It is a	fact of	life that no single method of streaming	is applicable
to a majority of today's computing and telecommunications
environments.  ZMODEM provides several data streaming methods
selected according to the limitations of the sending environment,
receiving environment, and transmission	channel(s).


9.1  FFuullll SSttrreeaammiinngg wwiitthh SSaammpplliinngg

If the receiver	can overlap serial I/O with disk I/O, and if the
sender can sample the reverse channel for the presence of data
without	having to wait,	full streaming can be used with	no AAttttnn
sequence required.  The	sender begins data transmission	with a ZZDDAATTAA
header and continuous ZZCCRRCCGG data subpackets.  When the receiver
detects	an error, it executes the AAttttnn sequence	and then sends a
ZZRRPPOOSS header with the correct position within the file.

At the end of each transmitted data subpacket, the sender checks for
the presence of	an error header	from the receiver.  To do this,	the
sender samples the reverse data	stream for the presence	of either a
ZPAD or	CAN character.[1] Flow control characters (if present) are
acted upon.

Other characters (indicating line noise) increment a counter which is
reset whenever the sender waits	for a header from the receiver.	 If
the counter overflows, the sender sends	the next data subpacket	as
ZCRCW, and waits for a response.

ZPAD indicates some sort of error header from the receiver.  A CAN
suggests the user is attempting	to "stop the bubble machine" by
keyboarding CAN	characters.  If	one of these characters	is seen, an
empty ZCRCE data subpacket is sent.  Normally, the receiver will have
sent an	ZRPOS or other error header, which will	force the sender to
resume transmission at a different address, or take other action.  In
the unlikely event the ZPAD or CAN character was spurious, the
receiver will time out and send	a ZRPOS	header.[2]

Then the receiver's response header is read and	acted upon.[3]


__________

 1. The	call to	rdchk()	in sszz..cc	performs this function.

 2. The	obvious	choice of ZCRCW	packet,	which would trigger an ZACK from
    the	receiver, is not used because multiple in transit frames could
    result if the channel has a	long propagation delay.

 3. The	call to	getinsync() in sszz..cc performs this function.



Chapter	9	      Rev Sep-03-90  Typeset 9-7-90			22







Chapter	9		     ZMODEM Protocol				23



A ZZRRPPOOSS	header resets the sender's file	offset to the correct
position.  If possible,	the sender should purge	its output buffers
and/or networks	of all unprocessed output data,	to minimize the
amount of unwanted data	the receiver must discard before receiving
data starting at the correct file offset.  The next transmitted	data
frame should be	a ZCRCW	frame followed by a wait to guarantee
complete flushing of the network's memory.

If the receiver	gets a ZZAACCKK header with	an address that	disagrees
with the sender	address, it is ignored,	and the	sender waits for
another	header.	 A ZZFFIINN, ZZAABBOORRTT, or TTIIMMEEOOUUTT terminates the session; a
ZZSSKKIIPP terminates the processing	of this	file.

The reverse channel is then sampled for	the presence of	another
header from the	receiver.[4] if	one is detected, the getinsync() C
function is again called to read another error header.	Otherwise,
transmission resumes at	the (possibly reset) file offset with a	ZZDDAATTAA
header followed	by data	subpackets.


9.1.1  WWiinnddooww MMaannaaggeemmeenntt
When sending data through a network, some nodes	of the network store
data while it is transferred to	the receiver.  7000 bytes and more of
transient storage have been observed.  Such a large amount of storage
causes the transmitter to "get ahead" of the reciever.	This can be
fatal with MEGAlink and	other protocols	that depend on timely
notification of	errors from the	receiver.  This	condition is not
fatal with ZMODEM, but it does slow error recovery.

To manage the window size, the sending program uses ZCRCQ data
subpackets to trigger ZACK headers from	the receiver.  The returning
ZACK headers inform the	sender of the receiver's progress.  When the
window size (current transmitter file offset - last reported receiver
file offset) exceeds a specified value,	the sender waits for a
ZACK[5]	packet with a receiver file offset that	reduces	the window
size.

Unix _s_z	versions beginning with	May 9 1987 control the window size
with the "-w N"	option,	where N	is the maximum window size.  Pro-YAM,
ZCOMM and DSZ versions beginning with May 9 1987 control the window
size with "zmodem pwN".	 This is compatible with previous versions of
these programs.[6]


__________

 4. If sampling	is possible.

 5. ZRPOS and other error packets are handled normally.

 6. When used with modems or networks that simultaneously assert flow



Chapter	9	      Rev Sep-03-90  Typeset 9-7-90			23







Chapter	9		     ZMODEM Protocol				24



9.2  FFuullll SSttrreeaammiinngg wwiitthh RReevveerrssee IInntteerrrruupptt

The above method cannot	be used	if the reverse data stream cannot be
sampled	without	entering an I/O	wait.  An alternate method is to
instruct the receiver to interrupt the sending program when an error
is detected.

The receiver can interrupt the sender with a control character,	break
signal,	or combination thereof,	as specified in	the AAttttnn sequence.
After executing	the AAttttnn sequence, the receiver	sends a	hex ZZRRPPOOSS
header to force	the sender to resend the lost data.

When the sending program responds to this interrupt, it	reads a	HEX
header (normally ZRPOS)	from the receiver and takes the	action
described in the previous section.  The	Unix sszz..cc program uses a
setjmp/longjmp call to catch the interrupt generated by	the AAttttnn
sequence.  Catching the	interrupt activates the	getinsync() C
function to read the receiver's	error header and take appropriate
action.

When compiled for standard SYSTEM III/V	Unix, sszz..cc uses	an AAttttnn
sequence of Ctrl-C followed by a 1 second pause	to interrupt the
sender,	then give the sender (Unix) time to prepare for	the
receiver's error header.


9.3  FFuullll SSttrreeaammiinngg wwiitthh SSlliiddiinngg WWiinnddooww

If none	of the above methods is	applicable, hope is not	yet lost.  If
the sender can buffer responses	from the receiver, the sender can use
ZCRCQ data subpackets to get ACKs from the receiver without
interrupting the transmission of data.	After a	sufficient number of
ZCRCQ data subpackets have been	sent, the sender can read one of the
headers	that should have arrived in its	receive	interrupt buffer.

A problem with this method is the possibility of wasting an excessive
amount of time responding to the receiver's error header.  It may be
possible to program the	receiver's AAttttnn	sequence to flush the
sender's interrupt buffer before sending the ZRPOS header.






__________________________________________________________________________

    control with XON and XOFF characters aanndd pass XON characters that
    violate flow control, the receiving	program	should have a revision
    date of May	9 or later.




Chapter	9	      Rev Sep-03-90  Typeset 9-7-90			24







Chapter	9		     ZMODEM Protocol				25



9.4  FFuullll SSttrreeaammiinngg oovveerr EErrrroorr FFrreeee CChhaannnneellss

File transfer protocols	predicated on the existence of an error	free
end to end communications channel have been proposed from time to
time.  Such channels have proven to be more readily available in
theory than in actuality.  The frequency of undetected errors
increases when modem scramblers	have more bits than the	error
detecting CRC.

A ZMODEM sender	assuming an error free channel with end	to end flow
control	can send the entire file in one	frame without any checking of
the reverse stream.  If	this channel is	completely transparent,	only
ZDLE need be escaped.  The resulting protocol overhead for average
long files is less than	one per	cent.[7]

9.5  SSeeggmmeenntteedd SSttrreeaammiinngg

If the receiver	cannot overlap serial and disk I/O, it uses the
ZZRRIINNIITT frame to	specify	a buffer length	which the sender will not
overflow.  The sending program sends a ZZCCRRCCWW data subpacket and	waits
for a ZZAACCKK header before sending the next segment of the file.

If the sending program supports	reverse	data stream sampling or
interrupt, error recovery will be faster (on average) than a protocol
(such as YMODEM) that sends large blocks.

A sufficiently large receiving buffer allows throughput	to closely
approach that of full streaming.  For example, 16kb segmented
streaming adds about 3 per cent	to full	streaming ZMODEM file
transfer times when the	round trip delay is five seconds.


10.  AATTTTEENNTTIIOONN SSEEQQUUEENNCCEE

The receiving program sends the	AAttttnn sequence whenever it detects an
error and needs	to interrupt the sending program.

The default AAttttnn string	value is empty (no Attn	sequence).  The
receiving program resets Attn to the empty default before each
transfer session.

The sender specifies the Attn sequence in its optional ZSINIT frame.
The AAttttnn string	is terminated with a null.



__________

 7. One	in 256 for escaping ZDLE, about	two (four if 32	bit CRC	is used)
    in 1024 for	data subpacket CRC's




Chapter	10	      Rev Sep-03-90  Typeset 9-7-90			25







Chapter	10		     ZMODEM Protocol				26



Two meta-characters perform special functions:

   o+ \335 (octal) Send a break signal

   o+ \336 (octal) Pause	one second


11.  FFRRAAMMEE TTYYPPEESS

The numeric values for the values shown	in boldface are	given in
_z_m_o_d_e_m._h.  Unused bits and unused bytes	in the header (ZP0...ZP3) are
set to 0.

11.1  ZZRRQQIINNIITT

Sent by	the sending program, to	trigger	the receiving program to send
its ZRINIT header.  This avoids	the aggravating	startup	delay
associated with	XMODEM and Kermit transfers.  The sending program may
repeat the receive invitation (including ZRQINIT) if a response	is
not obtained at	first.

ZF0 contains ZCOMMAND if the program is	attempting to send a command,
0 otherwise.

11.2  ZZRRIINNIITT

Sent by	the receiving program.	ZF0 and	ZF1 contain the	 bitwise or
of the receiver	capability flags:
#define	CANFDX	   01	/* Rx can send and receive true	FDX */
#define	CANOVIO	   02	/* Rx can receive data during disk I/O */
#define	CANBRK	   04	/* Rx can send a break signal */
#define	CANRLE	  010	/* Receiver can	decode RLE */
#define	CANLZW	  020	/* Receiver can	uncompress LZW */
#define	CANFC32	  040	/* Receiver can	use 32 bit Frame Check */
#define	ESCCTL	 0100	/* Receiver expects ctl	chars to be escaped
*/
#define	ESC8	 0200	/* Receiver expects 8th	bit to be escaped */

ZP0 and	ZP1 contain the	size of	the receiver's buffer in bytes,	or 0
if nonstop I/O is allowed.

11.3  ZZSSIINNIITT

The Sender sends flags followed	by a binary data subpacket terminated
with ZZCCRRCCWW.

/* Bit Masks for ZSINIT	flags byte ZF0 */
#define	TESCCTL	0100   /* Transmitter expects ctl chars	to be escaped
*/
#define	TESC8	0200   /* Transmitter expects 8th bit to be escaped
*/



Chapter	11	      Rev Sep-03-90  Typeset 9-7-90			26







Chapter	11		     ZMODEM Protocol				27



The data subpacket contains the	null terminated	AAttttnn sequence,
maximum	length 32 bytes	including the terminating null.

11.4  ZZAACCKK

Acknowledgment to a ZZSSIINNIITT frame, ZZCCHHAALLLLEENNGGEE header, ZZCCRRCCQQ or ZZCCRRCCWW
data subpacket.	 ZP0 to	ZP3 contain file offset.  The response to
ZCHALLENGE contains the	same 32	bit number received in the ZCHALLENGE
header.

11.5  ZZFFIILLEE

This frame denotes the beginning of a file transmission	attempt.
ZF0, ZF1, and ZF2 may contain options.	ZRWOVR,	if present, contain
the sender's override rx window	size/256.  A value of 0	in each	of
these bytes implies no special treatment.  Options specified to	the
receiver override options specified to the sender with the exception
of ZZCCBBIINN.  A ZZCCBBIINN from	the sender overrides any other Conversion
Option given to	the receiver except ZCRESUM.  A	ZZCCBBIINN from the
receiver overrides any other Conversion	Option sent by the sender.


11.5.1	ZZFF00:: CCoonnvveerrssiioonn	OOppttiioonn
If the receiver	does not recognize the Conversion Option, an
application dependent default conversion may apply.

ZZCCBBIINN "Binary" transfer	- inhibit conversion unconditionally

ZZCCNNLL Convert received end of line to local end of line
     convention.  The supported	end of line conventions	are
     CR/LF (most ASCII based operating systems except Unix
     and Macintosh), and NL (Unix).  Either of these two end
     of	line conventions meet the permissible ASCII
     definitions for Carriage Return and Line Feed/New Line.
     Neither the ASCII code nor	ZMODEM ZCNL encompass lines
     separated only by carriage	returns.  Other	processing
     appropriate to ASCII text files and the local operating
     system may	also be	applied	by the receiver.[1]

ZZCCRREECCOOVV	Recover/Resume interrupted file	transfer.  ZCREVOV is
     also useful for updating a	remote copy of a file that
     grows without resending of	old data.  If the destination
     file exists and is	no longer than the source, append to
     the destination file and start transfer at	the offset
     corresponding to the receiver's end of file.  This


__________

 1. Filtering RUBOUT, NULL, Ctrl-Z, etc.




Chapter	11	      Rev Sep-03-90  Typeset 9-7-90			27







Chapter	11		     ZMODEM Protocol				28



     option does not apply if the source file is shorter.
     Files that	have been converted (e.g., ZCNL) or subject
     to	a single ended Transport Option	cannot have their
     transfers recovered.

11.5.2	ZZFF11:: MMaannaaggeemmeenntt	OOppttiioonn
If the receiver	does not recognize the Management Option, the
file should be transferred normally.

The ZZMMSSKKNNOOLLOOCC bit instructs the	receiver to bypass the
current	file if	the receiver does not have a file with the
same name.

Five bits (defined by ZZMMMMAASSKK) define the following set of
mutually exclusive management options.

ZZMMNNEEWWLL Transfer	file if	destination file absent.  Otherwise,
     transfer file overwriting destination if the source file
     is	newer or longer.

ZZMMCCRRCC Compare the source and destination files.	 Transfer if
     file lengths or file polynomials differ.

ZZMMAAPPNNDD Append source file contents to the end of the existing
     destination file (if any).

ZZMMCCLLOOBB Replace existing	destination file (if any).

ZZMMDDIIFFFF Transfer	file if	destination file absent.  Otherwise,
     transfer file overwriting destination if files have
     different lengths or dates.

ZZMMPPRROOTT Protect destination file	by transferring	file only if
     the destination file is absent.

ZZMMNNEEWW Transfer file if destination file	absent.	 Otherwise,
     transfer file overwriting destination if the source file
     is	newer.

11.5.3	ZZFF22:: TTrraannssppoorrtt OOppttiioonn
If the receiver	does not implement the particular transport
option,	the file is copied without conversion for later
processing.

ZZTTLLZZWW Lempel-Ziv compression.  Transmitted data	will be
     identical to that produced	by ccoommpprreessss 44..00	operating on
     a computer	with VAX byte ordering,	using 12 bit
     encoding.

ZZTTRRLLEE Run Length encoding.  The	transmitter will use RLE
     encoded data subpackets.  The ZZTTRRLLEE bit is	used as	a



Chapter	11	      Rev Sep-03-90  Typeset 9-7-90			28







Chapter	11		     ZMODEM Protocol				29



     display flag, the actual encoding choice is indicated by
     the frame type.

A ZZCCRRCCWW	data subpacket follows with file name, file length,
modification date, and other information described in a	later
chapter.

11.5.4	ZZFF33:: EExxtteennddeedd OOppttiioonnss
The Extended Options are bit encoded.

ZZTTSSPPAARRSS	Special	processing for sparse files, or	sender managed
     selective retransmission.	Each file segment is transmitted as
     a separate	frame, where the frames	are not	necessarily
     contiguous.  The sender should end	each segment with a ZCRCW
     data subpacket and	process	the expected ZACK to insure no data
     is	lost.  ZTSPARS cannot be used with ZCNL.

11.6  ZZSSKKIIPP

Sent by	the receiver in	response to ZZFFIILLEE, makes the sender skip to
the next file.

11.7  ZZNNAAKK

Indicates last header was garbled.  (See also ZZRRPPOOSS).

11.8  ZZAABBOORRTT

Sent by	receiver to terminate batch file transfers when	requested by
the user.  Sender responds with	a ZZFFIINN sequence.[2]

11.9  ZZFFIINN

Sent by	sending	program	to terminate a ZMODEM session.	Receiver
responds with its own ZZFFIINN.

11.10  ZZRRPPOOSS

Sent by	receiver to force file transfer	to resume at file offset
given in ZP0...ZP3.  Some sending programs restrict acceptable ZRPOS
offsets.  Offsets of transmitted subpackets are	expected to be
acceptable.





__________

 2. Or ZZCCOOMMPPLL in case of server	mode.




Chapter	11	      Rev Sep-03-90  Typeset 9-7-90			29







Chapter	11		     ZMODEM Protocol				30



11.11  ZZDDAATTAA

ZP0...ZP3 contain file offset.	One or more data subpackets follow.

11.12  ZZEEOOFF

Sender reports End of File.  ZP0...ZP3 contain the ending file
offset.

11.13  ZZFFEERRRR

After receiving	a ZFILE	frame, but before the receiver sends ZRPOS,
ZFERR indicates	the output file	cannot be opened bcause	of an error
condition (write protected, illegal pathname, etc.).

Otherwise, indicates an	error in reading or writing file, protocol
equivalent to ZZAABBOORRTT.

11.14  ZZCCRRCC

Request	(receiver) and response	(sender) for file polynomial.
ZP0...ZP3 contain number of bytes (receiver) or	file polynomial
(sender).  Offset of segment to	checksum starts	at byte	6 of header,
or 0.[3] Number	of bytes and offset must be multiples of 1024.

11.15  ZZCCHHAALLLLEENNGGEE

Request	sender to echo a random	number in ZP0...ZP3 in a ZACK frame.
Sent by	the receiving program to the sending program to	verify that
it is connected	to an operating	program, and was not activated by
spurious data or a Trojan Horse	message.

11.16  ZZCCOOMMPPLL

Request	now completed.

11.17  ZZCCAANN

This is	a pseudo frame type returned by	gethdr() in response to	a
Session	Abort sequence.







__________

 3. Available with variable length headers.




Chapter	11	      Rev Sep-03-90  Typeset 9-7-90			30







Chapter	11		     ZMODEM Protocol				31



11.18  ZZFFRREEEECCNNTT

Sending	program	requests a ZACK	frame with ZP0...ZP3 containing	the
number of free bytes on	the current file system.  A value of 0
represents an indefinite amount	of free	space.

11.19  ZZCCOOMMMMAANNDD

ZCOMMAND is sent in a binary frame.  ZZFF00 contains 00 or ZZCCAACCKK11 (see
below).

A ZCRCW	data subpacket follows,	with the ASCII text command string
terminated with	a NULL character.  If the command is intended to be
executed by the	operating system hosting the receiving program
(e.g., "shell escape"),	it must	have "!" as the	first character.
Otherwise the command is meant to be executed by the application
program	which receives the command.

If the receiver	detects	an illegal or badly formed command, the
receiver immediately responds with a ZCOMPL header with	an error
code in	ZP0...ZP3.

If ZF0 contained ZZCCAACCKK11,, the receiver immediately responds with	a
ZCOMPL header with 0 status.

Otherwise, the receiver	responds with a	ZCOMPL header when the
operation is completed.	 The exit status of the	completed command is
stored in ZP0...ZP3.  A	0 exit status implies nominal completion of
the command.

If the command causes a	file to	be transmitted,	the command sender
will see a ZRQINIT frame from the other	computer attempting to send
data.

The sender examines ZF0	of the received	ZRQINIT	header to verify it
is not an echo of its own ZRQINIT header.  It is illegal for the
sending	program	to command the receiving program to send a command.

If the receiver	program	does not implement command downloading,	it
may display the	command	to the standard	error output, then return a
ZCOMPL header.



12.  SSEESSSSIIOONN TTRRAANNSSAACCTTIIOONN EEXXAAMMPPLLEESS









Chapter	12	      Rev Sep-03-90  Typeset 9-7-90			31







Chapter	12		     ZMODEM Protocol				32



12.1  AA	ssiimmppllee ffiillee ttrraannssffeerr

A simple transaction, one file,	no errors, no CHALLENGE, overlapped
I/O:

Sender	       Receiver

"rz\r"
ZRQINIT(0)
	       ZRINIT
ZFILE
	       ZRPOS
ZDATA data ...
ZEOF
	       ZRINIT
ZFIN
	       ZFIN
OO


12.2  CChhaalllleennggee	aanndd CCoommmmaanndd DDoowwnnllooaadd


Sender		    Receiver

"rz\r"
ZRQINIT(ZCOMMAND)
		    ZCHALLENGE(random-number)
ZACK(same-number)
		    ZRINIT
ZCOMMAND, ZDATA
		    (Performs Command)
		    ZCOMPL
ZFIN
		    ZFIN
OO


13.  ZZFFIILLEE FFRRAAMMEE FFIILLEE IINNFFOORRMMAATTIIOONN

ZMODEM sends the same file information with the	ZZFFIILLEE frame data
that YMODEM sends in its block 0.

NN..BB..:: TThhee ppaatthhnnaammee ((ffiillee nnaammee)) ffiieelldd iiss	mmaannddaattoorryy..

Pathname The pathname (conventionally, the file	name) is sent as a
     null terminated ASCII string.  This is the	filename format	used
     by	the handle oriented MSDOS(TM) functions	and C library fopen
     functions.	 An assembly language example follows:
			   DB	  'foo.bar',0
     No	spaces are included in the pathname.  Normally only the	file



Chapter	13	      Rev Sep-03-90  Typeset 9-7-90			32







Chapter	13		     ZMODEM Protocol				33



     name stem (no directory prefix) is	transmitted unless the
     sender has	selected YAM's ff option	to send	the ffuullll absolute or
     relative pathname.	 The source drive designator (A:, B:, etc.)
     usually is	not sent.

			 FFiilleennaammee CCoonnssiiddeerraattiioonnss

	o+ File names should be translated to lower case	unless the
	  sending system supports upper/lower case file	names.	This
	  is a convenience for users of	systems	(such as Unix) which
	  store	filenames in upper and lower case.

	o+ The receiver should accommodate file names in	lower and
	  upper	case.

	o+ When transmitting files between different operating
	  systems, file	names must be acceptable to both the sender
	  and receiving	operating systems.  If not, transformations
	  should be applied to make the	file names acceptable.	If
	  the transformations are unsuccessful,	a new file name	may
	  be invented be the receiving program.

     If	directories are	included, they are delimited by	/; i.e.,
     "subdir/foo" is acceptable, [subdir]foo and "subdir\foo" are
     not.

Length The file	length and each	of the succeeding fields are
     optional.[1] The length field is stored as	a decimal string
     counting the number of data bytes in the file.

     The ZMODEM	receiver uses the file length as an estimate only.
     It	may be used to display an estimate of the transmission time,
     and may be	compared with the amount of free disk space.  The
     actual length of the received file	is determined by the data
     transfer.	A file may grow	after transmission commences, and
     all the data will be sent.

Modification Date A single space separates the modification date
     from the file length.

     The mod date is optional, and the filename	and length may be
     sent without requiring the	mod date to be sent.

     The mod date is sent as an	octal number giving the	time the
     ccoonntteennttss of the file were last changed measured in	seconds	from


__________

 1. Fields may not be skipped.




Chapter	13	      Rev Sep-03-90  Typeset 9-7-90			33







Chapter	13		     ZMODEM Protocol				34



     Jan 1 1970	Universal Coordinated Time (GMT).  A date of 0
     implies the modification date is unknown and should be left as
     the date the file is received.

     This standard format was chosen to	eliminate ambiguities
     arising from transfers between different time zones.


File Mode A single space separates the file mode from the
     modification date.	 The file mode is stored as an octal string.
     Unless the	file originated	from a Unix system, the	file mode is
     set to 0.	rz(1) checks the file mode for the 0x8000 bit which
     indicates a Unix type regular file.  Files	with the 0x8000	bit
     set are assumed to	have been sent from another Unix (or
     similar) system which uses	the same file conventions.  Such
     files are not translated in any way.


Serial Number A	single space separates the serial number from the
     file mode.	 The serial number of the transmitting program is
     stored as an octal	string.	 Programs which	do not have a serial
     number should omit	this field, or set it to 0.  The receiver's
     use of this field is optional.


Number of Files	Remaining Iff the number of files remaining is sent,
     a single space separates this field from the previous field.
     This field	is coded as a decimal number, and includes the
     current file.  This field is an estimate, and incorrect values
     must not be allowed to cause loss of data.	 The receiver's	use
     of	this field is optional.


Number of Bytes	Remaining Iff the number of bytes remaining is sent,
     a single space separates this field from the previous field.
     This field	is coded as a decimal number, and includes the
     current file.  This field is an estimate, and incorrect values
     must not be allowed to cause loss of data.	 The receiver's	use
     of	this field is optional.


File Type Iff the file type is sent, a single space separates this
     field from	the previous field.  This field	is coded as a
     decimal number.  Currently	defined	values are:

     0	  Sequential file - no special type

     1	  Other	types to be defined.
     The receiver's use	of this	field is optional.





Chapter	13	      Rev Sep-03-90  Typeset 9-7-90			34







Chapter	13		     ZMODEM Protocol				35



The file information is	terminated by a	null.  If only the pathname
is sent, the pathname is terminated with ttwwoo nulls.  The length	of
the file information subpacket,	including the trailing null, must
not exceed 1024	bytes; a typical length	is less	than 64	bytes.




14.  PPEERRFFOORRMMAANNCCEE RREESSUULLTTSS

14.1  CCoommppaattiibbiilliittyy

Extensive testing has demonstrated ZMODEM to be	compatible with
satellite links, packet	switched networks, microcomputers,
minicomputers, regular and error correcting buffered modems at 75 to
19200 bps.  ZMODEM's economy of	reverse	channel	bandwidth allows
modems that dynamically	partition bandwidth between the	two
directions to operate at optimal speeds.

14.2  TThhrroouugghhppuutt

Between	two single task	PC-XT computers	sending	a program image	on
an in house Telenet link, SuperKermit provided 72 ch/sec throughput
at 1200	baud.  YMODEM-k	yielded	85 chars/sec, and ZMODEM provided
113 chars/sec.	XMODEM was not measured, but would have	been much
slower based on	observed network propagation delays.

Recent tests downloading large binary files to an IBM PC (4.7 mHz
V20) running YAMK 16.30	with table driven 32 bit CRC calculation
yielded	a throughput of	1870 cps on a 19200 bps	direct connection.

Tests with TELEBIT TrailBlazer modems have shown transfer rates
approaching 1400 characters per	second for long	files.	When files
are compressed,	effective transfer rates of 2000 characters per
second are possible.


14.3  EErrrroorr RReeccoovveerryy

Some tests of ZMODEM protocol error recovery performance have been
made.  A PC-AT with SCO	SYS V Xenix or DOS 3.1 was connected to	a PC
with DOS 2.1 either directly at	9600 bps or with unbuffered dial-up
1200 bps modems.  The ZMODEM software was configured to	use 1024
byte data subpacket lengths above 2400 bps, 256	otherwise.

Because	no time	delays are necessary in	normal file transfers, per
file negotiations are much faster than with YMODEM, the	only
observed delay being the time required by the program(s) to update
logging	files.

During a file transfer,	a short	line hit seen by the receiver



Chapter	14	      Rev Sep-03-90  Typeset 9-7-90			35







Chapter	14		     ZMODEM Protocol				36



usually	induces	a CRC error.  The interrupt sequence is	usually	seen
by the sender before the next data subpacket is	completely sent, and
the resultant loss of data throughput averages about half a data
subpacket per line hit.	 At 1200 bps this is would be about .75
second lost per	hit.  At 10-5 error rate, this would degrade
throughput by about 9 per cent.

The throughput degradation increases with increasing channel delay,
as more	data subpackets	in transit through the channel are discarded
when an	error is detected.

A longer noise burst that affects both the receiver and	the sender's
reception of the interrupt sequence usually causes the sender to
remain silent until the	receiver times out in 10 seconds.  If the
round trip channel delay exceeds the receiver's	10 second timeout,
recovery from this type	of error may become difficult.

Noise affecting	only the sender	is usually ignored, with one common
exception.  Spurious XOFF characters generated by noise	stop the
sender until the receiver times	out and	sends an interrupt sequence
which concludes	with an	XON.

In summation, ZMODEM performance in the	presence of errors resembles
that of	X.PC and SuperKermit.  Short bursts cause minimal data
retransmission.	 Long bursts (such as pulse dialing noises) often
require	a timeout error	to restore the flow of data.


15.  PPAACCKKEETT SSWWIITTCCHHEEDD NNEETTWWOORRKK CCOONNSSIIDDEERRAATTIIOONNSS

Flow control is	necessary for printing messages	and directories, and
for streaming file transfer protocols.	A non transparent flow
control	is incompatible	with XMODEM and	YMODEM transfers.  XMODEM
and YMODEM protocols require complete transparency of all 256 8	bit
codes to operate properly.

The "best" flow	control	(when X.25 or hardware CTS is unavailable)
would not "eat"	any characters at all.	When the PAD's buffer almost
fills up, an XOFF should be emitted.  When the buffer is no longer
nearly full, send an XON.  Otherwise, the network should neither
generate nor eat XON or	XOFF control characters.

On Telenet, this can be	met by setting CCIT X3 5:1 and 12:0 at bbootthh
ends of	the network.  For best throughput, parameter 64	(advance
ACK) should be set to something	like 4.	 Packets should	be forwarded
when the packet	is a full 128 bytes, or	after a	moderate delay
(3:0,4:10,6:0).

With PC-Pursuit, it is sufficient to set parameter 5 to	1 at both
ends after one is connected to the remote modem.




Chapter	15	      Rev Sep-03-90  Typeset 9-7-90			36







Chapter	15		     ZMODEM Protocol				37



	<ENTER>@<ENTER>
	set 5:1<ENTER>
	rst? 5:1<ENTER>
	cont<ENTER>

Unfortunately, many PADs do not	accept the "rst?" command.

For YMODEM, PAD	buffering should guarantee that	a minimum of 1040
characters can be sent in a burst without loss of data or generation
of flow	control	characters.  Failure to	provide	this buffering will
generate excessive retries with	YMODEM.

	     TTAABBLLEE 11..  Network and Flow	Control	Compatibility

______________________________________________________________________________
|   Connectivity    |  Interactive|  XMODEM|  WXMODEM|	SUPERKERMIT|  ZMODEM |
_|________________________________________|____________________________|__________________|____________________|____________________________|____________________|_
_|____________________|______________|_________|__________|______________|__________|
|Direct	Connect	    |  YES	  |  YES   |  YES    |	YES	   |  YES    |
_|____________________|______________|_________|__________|______________|__________|
|Network, no FC	    |  nnoo	  |  YES   |  (4)    |	(6)	   |  YES (1)|
_|____________________|______________|_________|__________|______________|__________|
|Net, transparent FC|  YES	  |  YES   |  YES    |	YES	   |  YES    |
_|____________________|______________|_________|__________|______________|__________|
|Net, non-trans. FC |  YES	  |  nnoo	   |  no (5) |	YES	   |  YES    |
_|____________________|______________|_________|__________|______________|__________|
|Network, 7 bit	    |  YES	  |  nnoo	   |  no     |	YES (2)	   |  YES (3)|
_|____________________|______________|_________|__________|______________|__________|

(1) ZMODEM can optimize	window size or burst length for	fastest
transfers.
(2) Parity bits	must be	encoded, slowing binary	transfers.
(3) Natural protocol extension possible	for encoding data to 7 bits.
(4) Small WXMODEM window size may may allow operation.
(5) Some flow control codes are	not escaped in WXMODEM.
(6) Kermit window size must be reduced to avoid	buffer overrun.


16.  RREEVVIISSIIOONNSS

9-7-90 Implementation dependent	restrictions on	ZRPOS offset noted.
General	cleanup.

12-14-88 ZMODEM	RLE compression	defined.  10-14-88 Pascal source
code now available in Phil Burn's PibTerm v4.2.	 6-24-88  An
exception to the previously unconditional ZCBIN	override: a ZCRESUM
specified by the receiver need not be overridden by the	sender's
ZCBIN.

11-18-87 Editorial improvements




Chapter	16	      Rev Sep-03-90  Typeset 9-7-90			37







Chapter	16		     ZMODEM Protocol				38



10-27-87 Optional fields added for number of files remaining to	be
sent and total number of bytes remaining to be sent.

07-31-1987 The receiver	should ignore a	ZEOF with an offset that
does not match the current file	length.	 The previous action of
responding with	ZRPOS caused transfers to fail if a CRC	error
occurred immediately before end	of file, because two retransmission
requests were being sent for each error.  This has been	observed
under exceptional conditions, such as data transmission	at speeds
greater	than the receiving computer's interrupt	response capabilitiy
or gross misapplication	of flow	control.

Discussion of the Tx backchannel garbage count and ZCRCW after error
ZRPOS was added.  Many revisions for clarity.

07-09-87 Corrected XMODEM's development	date, incorrectly stated as
1979 instead of	the actual August 1977.	 More performance data was
added.

05-30-87 Added ZMNEW and ZMSKNOLOC

05-14-87 Window	management, ZACK zshhdr	XON removed, control
character escaping, ZMSPARS changed to ZXPARS, editorial changes.

04-13-87  The ZMODEM file transfer protocol's public domain status
is emphasized.

04-04-87: minor	editorial changes, added conditionals for overview
version.

03-15-87: 32 bit CRC added.

12-19-86: 0 Length ZCRCW data subpacket	sent in	response to ZPAD or
ZDELE detected on reverse channel has been changed to ZCRCE.  The
reverse	channel	is now checked for activity before sending each
ZDATA header.

11-08-86: Minor	changes	for clarity.

10-2-86:  ZCNL definition expanded.

9-11-86:  ZMPROT file management option	added.

8-20-86:  More performance data	included.

8-4-86:	 ASCII DLE (Ctrl-P, 020) now escaped; compatible with
previous versions.  More document revisions for	clarity.

7-15-86: This document was extensively edited to improve clarity and
correct	small errors.  The definition of the ZMNEW management option
was modified, and the ZMDIFF management	option was added.  The



Chapter	16	      Rev Sep-03-90  Typeset 9-7-90			38







Chapter	16		     ZMODEM Protocol				39



cancel sequence	was changed from two to	five CAN characters after
spurious two character cancel sequences	were detected.


17.  MMOORREE IINNFFOORRMMAATTIIOONN

Please contact Omen Technology for typeset copies of this document.

Current	versions of this document are available	in Omen	Technology's
ZMODEM Developer's Collection ($89.00).	 This collection includes
royalty	free C source code for XMODEM, YMODEM and ZMODEM protocols.

17.1  TTeelleeGGooddzziillllaa BBuulllleettiinn BBooaarrdd

More information may be	obtained by calling the	TeleGodzilla
bulletin board at 503-621-3746.	 TeleGodzilla supports 9600 (V32),
2400 and 1200 bps callers with automatic speed recognition.

Relevant files include YAMDEMO.ZOO, YAMHELP.ZOO, ZCOMMEXE.ZIP,
ZCOMMDOC.ZIP, ZCOMMHLP.ZIP.

Useful commands	for TeleGodzilla include "menu", "dir",	"sx file
(XMODEM)", "kermit sb file ...", and "sz file ...".


18.  ZZMMOODDEEMM PPRROOGGRRAAMMSS

TeleGodzilla and other bulletin	boards feature ZZCCOOMMMM, a	shareware
communications program.	 ZCOMM includes	Omen Technology's
TurboLearn(TM) Script Writer, ZMODEM, Omen's highly acclaimed XMODEM
and YMODEM protocol support, Sliding Windows Kermit, several
traditional protocols, a powerful script language, and the most
accurate VT100/102 emulation available in a shareware program.	The
ZCOMM files include:

  o+ ZZCCOOMMMMEEXXEE..ZZIIPP Executable files and beginner's telephone directory

  o+ ZZCCOOMMMMDDOOCC..ZZIIPP "Universal Line Printer Edition" Manual

  o+ ZZCCOOMMMMHHLLPP..ZZIIPP Tree structured Flash-UP help processor and
    database

Omen Technology	provides Professional-YAM, a full featured
communications program for DOS,	OS/2, Xenix and	Unix.  Source code
is available under license for various forms of	SYS V Unix.

Shareware C source code	and manual pages for the Unix/Xenix _r_z and
_s_z programs are	available on TeleGodzilla in _R_Z_S_Z._Z_O_O.	This ZOO
archive	may be unpacked	with _L_O_O_Z._E_X_E, also available on
TeleGodzilla.  Most Unix like systems are supported, including V7,
Sys III, 4.x BSD, SYS V, Idris,	Coherent, and Regulus.



Chapter	18	      Rev Sep-03-90  Typeset 9-7-90			39







Chapter	18		     ZMODEM Protocol				40



_R_Z_S_Z._Z_O_O includes a ZCOMM/Pro-YAM/PowerCom script _Z_U_P_L._T to upload
the small (178 lines) YMODEM bootstrap program _M_I_N_I_R_B._C	without	a
file transfer protocol.	 _M_I_N_I_R_B	uses the Unix stty(1) program to set
the required raw tty modes, and	compiles without special flags on
virtually all Unix and Xenix systems.  _Z_U_P_L._T directs the Unix
system to compile _M_I_N_I_R_B, then uses it as a bootstrap to upload	the
rz/sz source and manual	files.

Pascal source code for ZMODEM support is available in PibTerm v4.2
written	by Phil	Burns.


18.1  AAddddiinngg ZZMMOODDEEMM ttoo DDOOSS PPrrooggrraammss

_D_S_Z is a small shareware program that supports XMODEM, YMODEM, and
ZMODEM file transfers.	_D_S_Z is designed	to be called from a bulletin
board program or another communications	program.  It may be called
as
		     dsz port 2	sz file1 file2
to send	files, or as
			   dsz port 2 rz
to receive zero	or more	file(s), or as
		     dsz port 2	rz filea fileb
to receive two files, the first	to _f_i_l_e_a and the second	(if sent) to
_f_i_l_e_b.	This form of _d_s_z may be	used to	control	the pathname of
incoming file(s).  In this example, if the sending program attempted
to send	a third	file, the transfer would be terminated.

_D_s_z uses DOS stdout for	messages (no direct CRT	access), acquires
the COMM port vectors with standard DOS	calls, and restores the	COMM
port's interrupt vector	and registers upon exit.

Further	information on _d_s_z may be found	in _d_s_z._d_o_c and the ZCOMM or
Pro-YAM	user manuals.


19.  CCOONNSSUULLTTIINNGG	SSEERRVVIICCEESS

Consulting on ZMODEM is	available at $120.00 per hour.	A purchase
order for consulting services with prepayment for two hours
consulting is required before obtaining	services.  Questions about
ZMODEM may be directed to:

     Omen Technology Inc
     17505-V Sauvie Island Road
     Portland Oregon 97231
     VOICE: 503-621-3406 :VOICE
     Modem (TeleGodzilla): 503-621-3746	FAX: 503-621-3735
     Usenet: ...!tektronix!reed!omen!caf
     Compuserve: 70007,2304




Chapter	19	      Rev Sep-03-90  Typeset 9-7-90			40







Chapter	19		     ZMODEM Protocol				41



20.  RREELLAATTEEDD FFIILLEESS

The following files should be consulted	by one studying	this
document:

YYMMOODDEEMM..DDOOCC Describes the XMODEM, XMODEM-1k, and	YMODEM file transfer
	protocols.  Part of the	ZMODEM Developer's Collection.

zzmmooddeemm..hh Definitions for ZMODEM	manifest constants

rrzz..cc,, sszz..cc,, rrbbssbb..cc Unix	source code for	operating ZMODEM programs.

rrzz..11,, sszz..11 Manual pages	for rz and sz (Troff sources).

zzmm..cc	Operating system independent low level ZMODEM subroutines.

mmiinniirrbb..cc A YMODEM bootstrap program, 178 lines.

RRZZSSZZ..ZZOOOO,,rrzzsszz..aarrcc Contain the C	source code and	manual pages listed
	above, plus a ZCOMM script to upload minirb.c to a Unix	or
	Xenix system, compile it, and use the program to upload	the
	ZMODEM source files with error checking.

DDSSZZ..ZZIIPP	Contains DSZ.COM, a shareware X/Y/ZMODEM subprogram,
	DESQview "pif" files for background operation in minimum
	memory,	and DSZ.DOC.

ZZCCOOMMMM**..ZZIIPP Archive files for ZCOMM, a powerful shareware
	communications program.

























Chapter	20	      Rev Sep-03-90  Typeset 9-7-90			41







Chapter	20		     ZMODEM Protocol				42



21.  AACCKKNNOOWWLLEEDDGGMMEENNTTSS


		 Copyright 1990	Omen Technology	INC
			All Rights Reserved

The High Reliability Software(TM), TurboLearn Script Writer(TM),
Cybernetic Data	Recovery(TM), AutoDownload(TM),	ZMODEM-90(TM),
MobyTurbo(TM), Intelligent Crash Recovery(TM), Error
Containment(TM), Full Time Capture(TM),	True YMODEM(TM),
OverThruster(TM), Password Guardian(TM), CryptoScript(TM), and
TurboDial(TM) are Omen Technology trademarks.

ZMODEM was developed _f_o_r _t_h_e _p_u_b_l_i_c _d_o_m_a_i_n under a Telenet contract.
The ZMODEM protocol descriptions are public domain.  No	licensing,
trademark, or copyright	restrictions apply to the use of the
protocol described here, or in using the _Z_M_O_D_E_M	name to	identify
this protocol.

Encouragement and suggestions by Thomas	Buck, Ward Christensen,	Earl
Hall, Irv Hoff,	Stuart Mathison, and John Wales, are gratefully
acknowledged.  32 bit CRC code courtesy	Gary S.	Brown.
































Chapter	21	      Rev Sep-03-90  Typeset 9-7-90			42











			      CONTENTS


 1.  INTENDED AUDIENCE................................................	 2

 2.  WHY DEVELOP ZMODEM?..............................................	 2

 3.  ZMODEM Protocol Design Criteria..................................	 5
     3.1    Ease of Use...............................................	 5
     3.2    Throughput................................................	 5
     3.3    Integrity and Robustness..................................	 6
     3.4    Ease of Implementation....................................	 6

 4.  EVOLUTION OF ZMODEM..............................................	 7

 5.  ROSETTA STONE....................................................	10

 6.  ZMODEM REQUIREMENTS..............................................	11
     6.1    File Contents.............................................	11

 7.  ZMODEM BASICS....................................................	12
     7.1    Packetization.............................................	12
     7.2    Link Escape	Encoding......................................	12
     7.3    Header....................................................	13
     7.4    Binary Data	Subpackets....................................	16
     7.5    RLE	Binary Data Subpackets................................	16
     7.6    RLE	Binary Data Subpackets with 8th	Bit Quoting...........	17
     7.7    ASCII Encoded Data Subpacket..............................	17

 8.  PROTOCOL TRANSACTION OVERVIEW....................................	17
     8.1    Session Startup...........................................	17
     8.2    File Transmission.........................................	19
     8.3    Session Cleanup...........................................	21
     8.4    Session Abort Sequence....................................	21

 9.  STREAMING TECHNIQUES / ERROR RECOVERY............................	22
     9.1    Full Streaming with	Sampling..............................	22
     9.2    Full Streaming with	Reverse	Interrupt.....................	24
     9.3    Full Streaming with	Sliding	Window........................	24
     9.4    Full Streaming over	Error Free Channels...................	25
     9.5    Segmented Streaming.......................................	25

10.  ATTENTION SEQUENCE...............................................	25

11.  FRAME TYPES......................................................	26
     11.1   ZRQINIT...................................................	26
     11.2   ZRINIT....................................................	26
     11.3   ZSINIT....................................................	26
     11.4   ZACK......................................................	27
     11.5   ZFILE.....................................................	27
     11.6   ZSKIP.....................................................	29



				  - i -











     11.7   ZNAK......................................................	29
     11.8   ZABORT....................................................	29
     11.9   ZFIN......................................................	29
     11.10  ZRPOS.....................................................	29
     11.11  ZDATA.....................................................	30
     11.12  ZEOF......................................................	30
     11.13  ZFERR.....................................................	30
     11.14  ZCRC......................................................	30
     11.15  ZCHALLENGE................................................	30
     11.16  ZCOMPL....................................................	30
     11.17  ZCAN......................................................	30
     11.18  ZFREECNT..................................................	31
     11.19  ZCOMMAND..................................................	31

12.  SESSION TRANSACTION EXAMPLES.....................................	31
     12.1   A simple file transfer....................................	32
     12.2   Challenge and Command Download............................	32

13.  ZFILE FRAME FILE INFORMATION.....................................	32

14.  PERFORMANCE RESULTS..............................................	35
     14.1   Compatibility.............................................	35
     14.2   Throughput................................................	35
     14.3   Error Recovery............................................	35

15.  PACKET SWITCHED NETWORK CONSIDERATIONS...........................	36

16.  REVISIONS........................................................	37

17.  MORE INFORMATION.................................................	39
     17.1   TeleGodzilla Bulletin Board...............................	39

18.  ZMODEM PROGRAMS..................................................	39
     18.1   Adding ZMODEM to DOS Programs.............................	40

19.  CONSULTING	SERVICES..............................................	40

20.  RELATED FILES....................................................	41

21.  ACKNOWLEDGMENTS..................................................	42


LIST OF	FIGURES


Figure 1.  Order of Bytes in Header...................................	14

Figure 2.  16 Bit CRC Binary Header...................................	14

Figure 3.  32 Bit CRC Binary Header...................................	15




				  - ii -











Figure 4.  HEX Header.................................................	16


LIST OF	TABLES


TABLE 1.  Network and Flow Control Compatibility......................	37















































				 - iii -









	   The ZMODEM Inter Application	File Transfer Protocol

			      Chuck Forsberg

			   Omen	Technology Inc


				 _A_B_S_T_R_A_C_T



The ZMODEM file	transfer protocol provides reliable file and command
transfers with complete	EENNDD--TTOO--EENNDD data	integrity between applications.
ZMODEM's 32 bit	CRC protects against errors that continue to sneak into
even the most advanced networks.

ZMODEM safeguards all data and supervisory information with effective
error detection.  Protocols without this protection were being developed
as late	as 1990.

ZMODEM rapidly transfers files,	particularly with buffered (error
correcting) modems, timesharing	systems, satellite relays, and wide area
packet switched	networks.  Optional LZW	and RLE	compression can	provide
even faster transfers.

User Friendliness is an	important ZMODEM feature.  ZMODEM AutoDownload
(Automatic file	Download initiated without user	intervention) greatly
simplifies file	transfers compared to the traditional protocols.

ZMODEM provides	advanced file management features including Crash
Recovery, flexible control of selective	file transfers,	and security
verified command downloading.

ZMODEM protocol	features allow implementation on a wide	variety	of systems
operating in a wide variety of environments.  A	choice of buffering and
windowing modes	allows ZMODEM to operate on systems that cannot	support
other streaming	protocols.  Finely tuned control character escaping allows
operation with real world networks without Kermit's high overhead.

ZMODEM is the only high	performance high reliability public protocol that
does not require large buffer allocations for normal file transfers.

Although ZMODEM	software is more complex than unreliable XMODEM	routines,
a comphrensive protocol	description and	actual C source	code to	pprroodduuccttiioonn
programs have allowed dozens of	developers to upgrade their applications
with efficient,	reliable ZMODEM	file transfers with a minimum of effort.

Basic ZMODEM was developed _f_o_r _t_h_e _p_u_b_l_i_c _d_o_m_a_i_n under a Telenet contract.
The basic ZMODEM protocol descriptions are public domain.  No licensing,
trademark, or copyright	restrictions apply to the use of the basic
protocol and the _Z_M_O_D_E_M	name.










