%!PS-Adobe-1.0
%% This is my font for chess and similar pieces.  It is supplied "as is".
%% It works for me, I have no idea whether it will work for you;  you gets
%% what you pays for.  Before using it, you should read the Copyright
%% notice below and the "README" file which should accompany this file.
%%    -- ANW, March 1991.

/Cfont 9 dict dup begin

/FontMatrix [ 0.001 0 0 0.001 0 0 ] readonly def
/FontType 3 def
/FontBBox [ 0 0 0 0 ] readonly def
/Encoding 256 array def
/FontInfo 3 dict dup begin
  /Notice (

	Copyright (c) 1991 A. N. Walker.  All rights reserved.

	This notice must be preserved in all versions of this file, and
	any alterations which you make must be clearly marked as such.
	For further information, see the "README" file which should
	accompany this, or contact me at Dept of Mathematics, Nottingham
	Univ., UK, anw@maths.nott.ac.uk.

     ) readonly def
  /FullName (ChessFont) readonly def
  /version (2.0) readonly def
end def
/UniqueID 472474 def

Encoding
0 1 255 { 2 copy /.notdef put pop } for
dup 8#040 /Wsquare put		% ' '
dup 8#042 /flap put		% '"'
dup 8#043 /board put		% '#'
dup 8#047 /flip put		% ''''
dup 8#052 /Bsquare put		% '*'
dup 8#055 /edge put		% '-'
dup 8#056 /blobfig put		% '.'
dup 8#057 /corner put		% '/'
dup 8#060 /m0 put		% '0'
dup 8#061 /Wsquare put		% '1'
dup 8#062 /m2 put		% '2'
dup 8#063 /m3 put		% '3'
dup 8#064 /m4 put		% '4'
dup 8#065 /m5 put		% '5'
dup 8#066 /m6 put		% '6'
dup 8#067 /m7 put		% '7'
dup 8#070 /m8 put		% '8'
dup 8#071 /m9 put		% '9'
dup 8#073 /nextline put		% ';'
dup 8#074 /m-1 put		% '<'
dup 8#076 /Wsquare put		% '>'
dup 8#100 /wblock put		% '@'
dup 8#102 /WB put		% 'B'
dup 8#103 /WC put		% 'C'
dup 8#104 /WD put		% 'D'
dup 8#105 /WE put		% 'E'
dup 8#106 /WF put		% 'F'
dup 8#107 /WG put		% 'G'
dup 8#111 /blob put		% 'I'
dup 8#113 /WK put		% 'K'
dup 8#114 /WL put		% 'L'
dup 8#115 /WM put		% 'M'
dup 8#116 /WN put		% 'N'
dup 8#117 /BO put		% 'O'
dup 8#120 /WP put		% 'P'
dup 8#121 /WQ put		% 'Q'
dup 8#122 /WR put		% 'R'
dup 8#123 /WS put		% 'S'
dup 8#124 /WT put		% 'T'
dup 8#125 /WU put		% 'U'
dup 8#126 /WV put		% 'V'
dup 8#130 /WX put		% 'X'
dup 8#132 /WZ put		% 'Z'
dup 8#133 /posstart put		% '['
dup 8#135 /posfinish put	% ']'
dup 8#137 /underbar put		% '_'
dup 8#142 /BB put		% 'b'
dup 8#143 /BC put		% 'c'
dup 8#144 /BD put		% 'd'
dup 8#145 /BE put		% 'e'
dup 8#146 /BF put		% 'f'
dup 8#147 /BG put		% 'g'
dup 8#151 /blob put		% 'i'
dup 8#153 /BK put		% 'k'
dup 8#154 /BL put		% 'l'
dup 8#155 /BM put		% 'm'
dup 8#156 /BN put		% 'n'
dup 8#157 /BO put		% 'o'
dup 8#160 /BP put		% 'p'
dup 8#161 /BQ put		% 'q'
dup 8#162 /BR put		% 'r'
dup 8#163 /BS put		% 's'
dup 8#164 /BT put		% 't'
dup 8#165 /BU put		% 'u'
dup 8#166 /BV put		% 'v'
dup 8#170 /BX put		% 'x'
dup 8#172 /BZ put		% 'z'
dup 8#174 /sidebar put		% '|'
dup 8#240 /Wsquare put		% ' '+
dup 8#241 /without put		% '!'+
dup 8#242 /flap put		% '"'+
dup 8#243 /board put		% '#'+
dup 8#245 /infinityequals put	% '%'+
dup 8#247 /flip put		% ''''+
dup 8#252 /circledot put	% '*'+
dup 8#253 /plus put		% '+'+
dup 8#255 /minus put		% '-'+
dup 8#272 /doubled put		% ':'+
dup 8#273 /nextline put		% ';'+
dup 8#274 /equalsplus put	% '<'+
dup 8#275 /equal put		% '='+
dup 8#276 /plusequals put	% '>'+
dup 8#277 /infinity put		% '?'+
dup 8#300 /circarrow put	% '@'+
dup 8#302 /Bfig put		% 'B'+
dup 8#303 /Cfig put		% 'C'+
dup 8#304 /Dfig put		% 'D'+
dup 8#305 /Efig put		% 'E'+
dup 8#306 /Ffig put		% 'F'+
dup 8#307 /Gfig put		% 'G'+
dup 8#311 /blobfig put		% 'I'+
dup 8#313 /Kfig put		% 'K'+
dup 8#314 /Lfig put		% 'L'+
dup 8#315 /Mfig put		% 'M'+
dup 8#316 /Nfig put		% 'N'+
dup 8#317 /Ofig put		% 'O'+
dup 8#320 /Pfig put		% 'P'+
dup 8#321 /Qfig put		% 'Q'+
dup 8#322 /Rfig put		% 'R'+
dup 8#323 /Sfig put		% 'S'+
dup 8#324 /Tfig put		% 'T'+
dup 8#325 /Ufig put		% 'U'+
dup 8#326 /Vfig put		% 'V'+
dup 8#330 /Xfig put		% 'X'+
dup 8#332 /Zfig put		% 'Z'+
dup 8#333 /minusorplus put	% '['+
dup 8#335 /plusorminus put	% ']'+
dup 8#336 /uparrow put		% '^'+
dup 8#341 /rightarrow put	% 'a'+
dup 8#342 /semicircle put	% 'b'+
dup 8#343 /centre put		% 'c'+
dup 8#344 /diags put		% 'd'+
dup 8#345 /etc put		% 'e'+
dup 8#346 /Phalo put		% 'f'+
dup 8#347 /samebs put		% 'g'+
dup 8#350 /edgefig put		% 'h'+
dup 8#351 /triangle put		% 'i'+
dup 8#352 /Bsquarefig put	% 'j'+
dup 8#353 /kside put		% 'k'+
dup 8#354 /line put		% 'l'+
dup 8#355 /hash put		% 'm'+
dup 8#356 /cornerfig put	% 'n'+
dup 8#357 /square put		% 'o'+
dup 8#360 /ending put		% 'p'+
dup 8#361 /qside put		% 'q'+
dup 8#362 /Pfill put		% 'r'+
dup 8#363 /separated put	% 's'+
dup 8#364 /tempo put		% 't'+
dup 8#365 /united put		% 'u'+
dup 8#366 /oppbs put		% 'v'+
dup 8#367 /with put		% 'w'+
dup 8#370 /weakpt put		% 'x'+
dup 8#371 /bpair put		% 'y'+
dup 8#372 /circlebolddot put	% 'z'+
    8#374 /botharrow put	% '|'+

/CharProcs 200 dict dup begin

% Miscellaneous:
	/.notdef { } bind def
	/Arcto  { arcto 4 { pop } repeat } bind def
	/Ddn3c  { dup dup neg 3 copy } bind def
	/Round  { dtransform round exch round exch idtransform } bind def
	/Rlineto { Round rlineto } bind def
	/Rmoveto { Round rmoveto } bind def
	/diamond { moveto dup neg 0 rmoveto dup dup neg rlineto
		dup dup rlineto dup neg exch rlineto closepath } bind def
	/dohalo { gsave 100 setlinewidth setW stroke grestore } bind def
	/dofill { gsave fill grestore } bind def
	/motion { 1000 mul exch 1000 mul exch setcharwidth } bind def
	/setW	{ 1 setgray } bind def
	/setB	{ 0 setgray } bind def
	/drawingB { 0 currentgray eq } bind def
	/setfig { 1000 0 0 -200 1000 800 setcachedevice 500 300 translate
		} bind def
	/setpce { 1000 0 setcharwidth 500 dup translate 0.95 dup scale
		} bind def
	/MiscStr (a) def
	/tofig  { 0 get 8#200 add MiscStr exch 0 exch put MiscStr } bind def
	/Tofig  { 1 0.95 div dup scale tofig } bind def
	/intext true def
	/flip	{ 0 0 setcharwidth /intext intext not def } bind def
	/flap	{ 0 0 setcharwidth /intext true def } bind def
	/Setfont { /ChessFont findfont 1000 scalefont setfont } bind def
	/Show	{ rotate -500 dup moveto Setfont show } bind def
	/Showfig { rotate -500 -300 moveto Setfont show } bind def
	/LocStr (a) def
	/SetChar {
		dup 8#047 eq { pop flip stop } if
		dup 8#200 lt { intext {
			8#200 add LocStr exch 0 exch put
			Setfont LocStr dup stringwidth setcharwidth
			0 0 moveto show stop } if } if } bind def
	/DoChar { Encoding exch get cvx exec } bind def

% Kings
	/WK {	setpce Kout dohalo setW dofill setB stroke Kin } bind def
	/BK {	setpce Kout dohalo dofill stroke setW Kin } bind def
	/Kfig { setfig Kout stroke Kin } bind def

	/Kout {	2 setmiterlimit
		325 -100 moveto 600 100 350 400 125 250 curveto
		0 250 rlineto -250 0 rlineto 0 -250 rlineto
		-350 400 -600 100 -325 -100 curveto 0 -250 rlineto
		-100 -500 100 -500 325 -350 curveto closepath
		30 setlinewidth } bind def
	/Kin {	drawingB { 325 } { 275 } ifelse
		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto
		-350 lineto -100 moveto 0 -50 3 -1 roll
		-100 800 Arcto -100 lineto
		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
		drawingB { 125 } { 75 } ifelse
		Ddn3c dup dup 4 { 0 375 moveto rlineto } repeat
		drawingB { 0 -45 moveto 125 250 lineto -250 0 rlineto
			closepath } { 15 0 180 diamond 265 -95 moveto
			480 150 280 380 50 -50 curveto -265 -95 moveto
			-480 150 -280 380 -50 -50 curveto } ifelse
		stroke } bind def

% Queens
	/WQ {	setpce Qout dohalo setW dofill setB stroke Qin } bind def
	/BQ {	setpce Qout dohalo dofill stroke setW Qin } bind def
	/Qfig { setfig Qout stroke Qin } bind def

	/Qout {	2 setmiterlimit
		0 75 moveto -150 440 50 -80 280 arc -250 25 lineto
		-440 200 50 -60 300 arc -325 -100 lineto 0 -250 rlineto
		-100 -500 100 -500 325 -350 curveto 0 250 rlineto
		440 200 50 -120 240 arc 250 25 lineto 150 440 50 -100 260 arc
		closepath 30 setlinewidth } bind def
	/Qin {	drawingB { 325 } { 275 } ifelse
		Ddn3c -350 moveto 0 -300 3 -1 roll -350 800 Arcto -350 lineto
		-100 moveto 0 -50 3 -1 roll -100 800 Arcto -100 lineto
		15 0 -185 diamond 15 -250 -210 diamond 15 250 -210 diamond
		stroke } bind def

% Rooks
	/WR {	setpce Rout dohalo setW dofill setB stroke Rin } bind def
	/BR {	setpce Rout dohalo dofill stroke setW Rin } bind def
	/Rfig { setfig Rout stroke Rin } bind def

	/Rout { -325 -450 moveto 650 0 rlineto 0 50 rlineto -100 175 rlineto
		0 400 rlineto 50 75 rlineto 0 150 rlineto -86 0 rlineto
		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
		-30 -100 rlineto -86 0 rlineto -30 100 rlineto -86 0 rlineto
		0 -150 rlineto 50 -75 rlineto 0 -400 rlineto -100 -175 rlineto
		closepath 30 setlinewidth } bind def
	/Rin {	drawingB { -225 } { -195 } ifelse
		dup -225 moveto dup -2 mul 0 rlineto
		dup 175 moveto -2 mul 0 rlineto stroke } bind def

% Bishops
	/WB {	Bsetpce Bout setW dofill setB stroke Bin } bind def
	/BB {	Bsetpce Bout dofill stroke setW Bin } bind def
	/Bfig { Bsetfig Bout stroke Bin } bind def

	/Bsetpce { /Binpce true def setpce } bind def
	/Bsetfig { /Binpce false def setfig } bind def
	/Bout {	2 setmiterlimit
		-400 -500 moveto 100 100 300 0 400 100 rcurveto
		100 -100 300 0 400 -100 rcurveto 0 100 rlineto
		-100 100 -300 0 -400 100 rcurveto
		-100 -100 -300 0 -400 -100 rcurveto closepath
		200 -350 moveto 0 200 rlineto
		200 0 150 215 0 325 curveto -75 420 40 -90 270 arc
		-340 100 -340 100 -200 -150 curveto 0 -200 rlineto
		200 50 rlineto closepath 30 setlinewidth
		gsave	0 325 moveto 150 215 200 0 200 -150 curveto
			340 100 340 100 75 380 curveto 75 420 40 -90 270 arc
			closepath Binpce { dohalo setW dofill setB } if stroke
		grestore } bind def
	/Bin {  15 0 -225 diamond
		drawingB { 200 } { 150 } ifelse Ddn3c
		-350 moveto 20 rlineto -20 rlineto -150 moveto
		30 rlineto -30 rlineto stroke } bind def

% Knights
	/WN {	setpce Nout dohalo setW dofill setB stroke Nin } bind def
	/BN {	setpce Nout dohalo dofill stroke setW Nin } bind def
	/Nfig { setfig Nout stroke Nin } bind def

	/Nout {	2 setmiterlimit
		450 -450 moveto 450 200 150 350 -50 400 curveto
		-25 100 rlineto -75 -200 rlineto -75 150 rlineto
		0 -150 rlineto -125 -125 -325 -400 -275 -450 rcurveto
		75 -75 rlineto 100 130 rlineto 0 -200 rlineto
		50 -25 150 100 100 150 rcurveto 50 -50 150 75 125 150 rcurveto
		125 -300 -250 -250 -250 -450 curveto
		closepath 30 setlinewidth } bind def
	/Nin {  15 -200 150 diamond stroke
		drawingB {
			[ 100 100 ] 0 setdash 410 -450 moveto
			410 200 130 330 -60 380 curveto 50 setlinewidth
			stroke } {
			430 -430 moveto 430 200 150 350 -30 370 curveto
			150 250 390 200 390 -430 curveto fill }
		ifelse } bind def

% Pawns
	% Pawns are the only symbols which occur "frequently" in a chess
	% diagram, so we make a special effort to optimise their caching
	% behaviour.  Also, they are the only symbols for which this is
	% easy!

	/WP { setpce Setfont setW 0 0 moveto (f) tofig show setB (P) tofig
		-500 -300 rmoveto show } bind def
	/BP { setpce Setfont setW 0 0 moveto (f) tofig show setB (r) tofig
		show } bind def
	/Pfig { setfig Pout stroke Pin } bind def

	/Pout { 300 -450 moveto 200 -300  200 -300 75 -250 curveto
		125 -50 125 -50 75 150 curveto 125 150 100 0 90 arc
		0 300 100 -30 210 arc -125 150 100 90 180 arc
		150 0 rlineto -125 -50 -125 -50 -75 -250 curveto
		-200 -300 -200 -300 -300 -450 curveto
		closepath 50 setlinewidth } bind def
	/Pin { -75 150 moveto 150 0 rlineto stroke } bind def

	/Phalo { 0 0 -350 -500 350 450 setcachedevice
		Pout gsave 100 setlinewidth stroke grestore fill } bind def
	/Pfill { 0 0 -325 -475 375 425 setcachedevice
		Pout gsave stroke grestore fill } bind def

% Fous
	% There seem to be several styles of Fou (French Bishop) -- I have
	% selected the easiest to implement.  Anyone who *really* wants
	% this piece can do some work for themselves!

	/WF {	setpce Fout dohalo setW dofill setB stroke Fin } bind def
	/BF {	setpce Fout dohalo dofill stroke setW Fin } bind def
	/Ffig { setfig Fout stroke Fin } bind def

	/Fout { 2 setlinejoin
		-300 -400 moveto 150 300 rlineto -250 500 rlineto
		250 -125 rlineto 150 175 rlineto 150 -175 rlineto
		250 125 rlineto -250 -500 rlineto 150 -300 rlineto
		closepath 30 setlinewidth } bind def

	/Fin {  0 -400 150 dup mul 675 dup mul add sqrt
		drawingB { 600 300 } { 30 sub 600 270 } ifelse
		atan dup 180 sub neg arc
		400 drawingB not { 15 5 sqrt mul add } if
		dup neg 400 moveto dup dup -2 mul rlineto dup 2 mul rlineto
		30 -100 150 diamond 30 100 150 diamond
		0 175 moveto 0 -200 rlineto currentpoint stroke
		75 210 330 arc stroke } bind def

% Miscellaneous Fairy pieces

    % Grasshopper
	/WG {	setpce (Q) 180 Show } bind def
	/BG {	setpce (q) 180 Show } bind def
	/Gfig { setfig (Q) tofig 180 Showfig } bind def

    % Nightrider.  Real problemists use S for Knight and N for Nightrider;
    %	    the weight of tradition forces N for Knight, hence S here.
	/WS {	setpce (N) 180 Show } bind def
	/BS {	setpce (n) 180 Show } bind def
	/Sfig { setfig (N) tofig 180 Showfig } bind def

    % Zebra
	/WZ {	setpce (N) -90 Show } bind def
	/BZ {	setpce (n) -90 Show } bind def
	/Zfig { setfig (N) tofig -90 Showfig } bind def

    % Mao.  Also Camel, but C is for Chameleon.
	/WM {	setpce (N) 90 Show } bind def
	/BM {	setpce (n) 90 Show } bind def
	/Mfig { setfig (N) tofig 90 Showfig } bind def

    % Vao
	/WV {	setpce (B) 90 Show } bind def
	/BV {	setpce (b) 90 Show } bind def
	/Vfig { setfig (B) tofig 90 Showfig } bind def

    % Equihopper
	/WE {	setpce (Q) -90 Show } bind def
	/BE {	setpce (q) -90 Show } bind def
	/Efig { setfig (Q) tofig -90 Showfig } bind def

    % Leo.  Also Locust, Lion, Edgehog
	/WL {	setpce (Q) 90 Show } bind def
	/BL {	setpce (q) 90 Show } bind def
	/Lfig { setfig (Q) tofig 90 Showfig } bind def

    % Pao.  Also Empress.  Sorry, all Uther mnemonics seemed to be used Up.
	/WU {	setpce (R) 90 Show } bind def
	/BU {	setpce (r) 90 Show } bind def
	/Ufig { setfig (R) tofig 90 Showfig } bind def

    % Orphan -- NB, all Orphans are black!
	/BO {	setpce (p) 90 Show } bind def
	/Ofig { setfig 90 rotate Pout dofill stroke } bind def

    % Rose.  Gardeners will know why T is mnemonic for this.
	/WT {	setpce Tout dohalo setW dofill setB stroke Tin } bind def
	/BT {	setpce Tout dohalo dofill stroke setW Tin } bind def
	/Tfig { setfig Tout stroke Tin } bind def

	/Tout { 300 2 sqrt 1 sub mul
		8 { dup 300 exch dup -90 135 arc 45 rotate } repeat
		pop 50 setlinewidth } bind def
	/Tin {  drawingB { 270 } { 300 } ifelse
		8 { dup 0 0 moveto 0 lineto 45 rotate } repeat
		pop stroke } bind def

    % Chameleon
	/WC {	setpce Cout dohalo setW dofill setB stroke } bind def
	/BC {	setpce Cout dohalo dofill stroke } bind def
	/Cfig { setfig Cout stroke } bind def

	/Cout { 2 setmiterlimit 50 setlinewidth
		-250 -350 moveto 500 0 rlineto -500 700 rlineto
		500 0 rlineto closepath } bind def

    % Blob [for marking squares], also for Imitator
	/blob { setpce 0 0 250 0 360 arc dohalo dofill } bind def
	/blobfig { setfig 0 200 250 0 360 arc dofill } bind def

% Draughts/Dame/Checkers pieces

    % Man
	/WD {	setpce Dout dohalo setW dofill setB stroke Din } bind def
	/BD {	setpce Dout dohalo dofill stroke setW Din } bind def
	/Dfig { setfig Dout stroke Din } bind def

	/Dout { 1 0.5 scale 0 0 350 0 180 arc 0 -400 350 180 0 arc
		closepath 50 setlinewidth } bind def
	/Din {  0 0 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
		ifelse arc stroke 20 setlinewidth 0 0 220 0 360 arc stroke
		0 0 80 0 360 arc stroke } bind def

    % King.  The mnemonic for this is unknown.
	/WX {	setpce Xout dohalo setW dofill setB stroke Xin } bind def
	/BX {	setpce Xout dohalo dofill stroke setW Xin } bind def
	/Xfig { setfig Xout stroke Xin } bind def

	/Xout { 1 0.5 scale 0 400 350 0 180 arc 0 -400 350 180 0 arc
		closepath 50 setlinewidth } bind def
	/Xin {  0 400 350 drawingB { 180 0 } { 210 -30 20 setlinewidth }
		ifelse arc stroke 0 0 350 drawingB { 180 0 } { 210 -30 }
		ifelse arc stroke 20 setlinewidth 0 400 220 0 360 arc stroke
		0 400 80 0 360 arc stroke } bind def

% Board symbols

	/Wsquare { 1 0 motion } bind def
	/Bsquare { setpce (j) Tofig 90 Show } bind def
	/Bsquarefig { 1000 0 0 0 1000 1000 setcachedevice
		/xpix 62.5 dup dtransform /ypix exch def def
		/xpabs xpix abs def /ypabs ypix abs def
		xpabs ypabs lt {
			ypabs ceiling dup 4 lt { pop 4 } if
			dup ypix div xpix mul exch } {
			xpabs ceiling dup 4 lt { pop 4 } if
			dup xpix div ypix mul } ifelse
		idtransform pop abs dup 3 div setlinewidth dup 2 mul 2000
		{ dup 1000 lt { dup 0 moveto 0 exch lineto }
			{ 1000 sub dup 1000 moveto 1000 exch lineto }
			ifelse } for stroke } bind def
	/board { 10000 0 800 0 9200 8400 setcachedevice
%		Setfont intext /intext dup true def 1000 8200 moveto
%		4 { (hhhhhhhhn) show currentpoint translate -90 rotate } repeat
%		-90 rotate 0 7000 moveto
%	The above was the intention, but the borders sometimes fail to match
%	up by a pixel or two.  Hence the following!  However, the borders
%	work perfectly well for special purposes.
		Setfont intext /intext dup true def
		20 setlinewidth 940 140 moveto 8120 0 Rlineto 0 8120 Rlineto
		-8120 0 Rlineto closepath stroke
		80 setlinewidth 840 40 moveto 8320 0 Rlineto 0 8320 Rlineto
		-8320 0 Rlineto closepath stroke
		2000 200 moveto 90 rotate
		4 { (j j j j ; j j j j;) show } repeat exch def } bind def
	/nextline { -8 -1 motion } bind def
	/edge { setpce (h) Tofig 0 Show } bind def
	/edgefig { 1000 0 0 0 1000 200 setcachedevice
		20 setlinewidth 0 60 moveto 1000 0 rlineto stroke
		80 setlinewidth 0 160 moveto 1000 0 rlineto stroke } bind def
	/corner { setpce (n) Tofig 0 Show } bind def
	/cornerfig { 0 0 0 0 200 200 setcachedevice
		20 setlinewidth 0 60 moveto 60 0 rlineto 0 -60 rlineto stroke
		80 setlinewidth 0 160 moveto 160 0 rlineto 0 -160 rlineto
		stroke } bind def
	/posstart { -9 7.2 motion } bind def
	/posfinish { 1 -0.2 motion } bind def
	/m0 { 0.5 dup motion } bind def
	/m2 { 2 0 motion } bind def
	/m3 { 3 0 motion } bind def
	/m4 { 4 0 motion } bind def
	/m5 { 5 0 motion } bind def
	/m6 { 6 0 motion } bind def
	/m7 { 7 0 motion } bind def
	/m8 { 8 0 motion } bind def
	/m9 { 0 1 motion } bind def
	/m-1 { -1 0 motion } bind def
	/underbar { 1000 0 -40 -40 1040 40 setcachedevice 80 setlinewidth
		1 setlinecap 0 0 moveto 1000 0 lineto stroke } bind def
	/sidebar { 0 0 setcharwidth 80 setlinewidth
		1 setlinecap 0 0 moveto 0 1000 lineto stroke } bind def
	/wblock { 0 0 setcharwidth setW
		200 200 moveto 600 0 rlineto 0 600 rlineto -600 0 rlineto
		fill } bind def

% Informant symbols

	/plusequals { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
		100 10 moveto 800 0 rlineto 0 140 Rmoveto -800 0 rlineto
		0 300 Rmoveto 800 0 rlineto 500 150 moveto 0 650 rlineto
		stroke } bind def

	/equalsplus { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
		100 790 moveto 800 0 rlineto 0 -140 Rmoveto -800 0 rlineto
		0 -300 Rmoveto 800 0 rlineto 500 0 moveto 0 650 rlineto
		stroke } bind def

	/plusorminus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 15 moveto 800 0 rlineto 0 385 Rmoveto -800 0 rlineto
		500 0 moveto 0 800 rlineto stroke } bind def

	/minusorplus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 785 moveto 800 0 rlineto 0 -385 Rmoveto -800 0 rlineto
		500 0 moveto 0 800 rlineto stroke } bind def

	/plus { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 400 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
		stroke } bind def

	/minus { 1000 0 100 385 900 415 setcachedevice 30 setlinewidth
		100 400 moveto 800 0 rlineto stroke } bind def

	/equal { 1000 0 100 300 800 180 Round
		320 add exch 100 add exch setcachedevice 20 setlinewidth
		100 310 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
		stroke } bind def

	/infinity { 1000 0 95 60 905 540 setcachedevice 40 setlinewidth
		275 300 160 0 360 arc 660 300 225 -180 180 arc stroke
		} bind def

	/infinityequals { 1000 0 95 10 905 750 setcachedevice 30 setlinewidth
		275 250 160 0 360 arc 660 250 225 -180 180 arc
		100 565 moveto 800 0 rlineto 0 180 Rmoveto -800 0 rlineto
		stroke } bind def

	/circarrow {1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		500 400 385 0 30 arcn -200 0 rmoveto 200 0 rlineto
		0 200 rlineto stroke } bind def

	/circledot { 900 0 100 0 800 700 setcachedevice 20 setlinewidth
		450 350 20 0 360 arc fill 450 350 340 0 360 arc stroke
		} bind def

	/rightarrow { 1200 0 100 185 1115 615 setcachedevice 30 setlinewidth
		100 400 moveto 1000 0 rlineto -200 -200 rmoveto 200 200 rlineto
		-200 200 rlineto stroke } bind def

	/uparrow { 500 0 35 0 465 915 setcachedevice 30 setlinewidth
		250 0 moveto 0 900 rlineto -200 -200 rmoveto 200 200 rlineto
		200 -200 rlineto stroke } bind def

	/botharrow { 1200 0 100 70 1100 730 setcachedevice 20 setlinewidth
		100 280 moveto 990 0 rlineto -200 -200 rmoveto 200 200 rlineto
		-200 200 rlineto 1100 520 moveto -990 0 rlineto
		200 -200 rmoveto -200 200 rlineto 200 200 rlineto
		stroke } bind def

	/circlebolddot { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
		500 400 50 0 360 arc fill 500 400 390 0 360 arc stroke
		} bind def

	/hash { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 280 moveto 800 0 rlineto 0 240 Rmoveto -800 0 rlineto
		380 0 moveto 0 800 rlineto 240 0 Rmoveto 0 -800 rlineto
		stroke } bind def

	/triangle { 900 0 100 0 800 750 setcachedevice 30 setlinewidth
		100 15 moveto 350 735 rlineto 350 -735 rlineto
		closepath stroke } bind def

	/square { 900 0 100 0 680 680 Round
		20 add exch 120 add exch setcachedevice 20 setlinewidth
		110 10 moveto 680 0 Rlineto 0 680 Rlineto
		-680 0 Rlineto closepath stroke } bind def

	/semicircle { 1000 0 50 0 950 465 setcachedevice 30 setlinewidth
		500 15 435 0 180 arc closepath stroke } bind def

	/line { 1000 0 100 190 900 610 setcachedevice 20 setlinewidth
		220 300 moveto 560 0 rlineto 0 200 Rmoveto -560 0 rlineto
		310 200 moveto -200 200 rlineto 200 200 rlineto
		690 200 moveto 200 200 rlineto -200 200 rlineto
		stroke } bind def

	/diags { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
		110 120 moveto 670 dup rlineto 110 -110 Rmoveto
		-670 dup rlineto 640 790 moveto 250 0 rlineto
		0 -250 rlineto stroke } bind def

	/centre { 1000 0 100 0 780 780 Round
		20 add exch 120 add exch setcachedevice 20 setlinewidth
		110 10 moveto 780 0 Rlineto 0 780 Rlineto -780 0 Rlineto
		closepath 110 400 moveto 780 0 rlineto 500 10 moveto
		0 780 Rlineto stroke } bind def

	/kside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
		110 10 moveto 300 390 rlineto -300 390 rlineto
		180 0 Rmoveto 300 -390 rlineto -300 -390 rlineto
		stroke } bind def

	/qside { 700 0 100 0 600 800 setcachedevice 20 setlinewidth
		590 10 moveto -300 390 rlineto 300 390 rlineto
		-180 0 Rmoveto -300 -390 rlineto 300 -390 rlineto
		stroke } bind def

	/weakpt { 700 0 100 0 600 500 setcachedevice 30 setlinewidth
		110 10 moveto 480 480 rlineto 590 10 moveto -480 480 rlineto
		stroke } bind def

	/ending { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 15 moveto 800 0 rlineto 500 0 moveto 0 800 rlineto
		stroke } bind def

	/bpair { 1200 0 100 0 980 580 Round
		20 add exch 120 add exch setcachedevice 20 setlinewidth
		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
		closepath 110 10 moveto 980 580 Rmoveto -570 0 Rlineto
		0 -370 Rlineto 570 0 Rlineto closepath stroke } bind def

	/oppbs { 1200 0 100 0 1100 600 setcachedevice 20 setlinewidth
		110 10 moveto 570 0 Rlineto 0 370 Rlineto -570 0 Rlineto
		closepath stroke 1100 600 moveto -590 0 rlineto
		0 -390 rlineto 590 0 rlineto fill } bind def

	/samebs { 1200 0 100 0 1100 600 setcachedevice
		100 0 moveto 590 0 rlineto 0 390 rlineto -590 0 rlineto
		closepath 1100 600 moveto -590 0 rlineto 0 -390 rlineto
		590 0 rlineto fill } bind def

	/united { 1210 0 50 0 1160 530 setcachedevice 30 setlinewidth
		315 265 250 0 360 arc stroke 895 265 250 0 360 arc
		stroke } bind def

	/separated { 1550 0 50 0 1500 530 setcachedevice 30 setlinewidth
		315 265 250 0 360 arc stroke 1235 265 250 0 360 arc stroke
		665 30 60 0 360 arc fill 885 30 60 0 360 arc fill } bind def

	/doubled { 730 0 100 0 630 1160 setcachedevice 30 setlinewidth
		365 265 250 0 360 arc stroke 365 895 250 0 360 arc
		stroke } bind def

	/tempo { 1000 0 100 0 900 800 setcachedevice 20 setlinewidth
		110 400 moveto 500 400 390 0 360 arc 500 10 moveto
		0 790 rlineto stroke } bind def

	/with { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 800 moveto 0 -785 rlineto 785 0 rlineto stroke } bind def

	/without { 1000 0 100 0 900 800 setcachedevice 30 setlinewidth
		100 15 moveto 785 0 rlineto 0 785 rlineto stroke } bind def

	/etc { 500 0 100 0 270 800 Round
		exch 130 add exch setcachedevice 30 setlinewidth
		115 0 moveto 0 800 rlineto 270 0 Rmoveto 0 -800 rlineto
		stroke } bind def
end def

/BuildChar { exch begin CharProcs begin
	{ SetChar } stopped not { DoChar } if
	end end } bind def
end def

/ChessFont Cfont definefont pop
% Demo file to be appended to the Chess Font file & sent to your LaserWriter
%	(or whatever else you do with PostScript!).

% Miscellaneous useful procedures:

	% show string centred on the current point
/cshow { dup stringwidth -2 div exch -2 div exch rmoveto show } bind def

	% Draw rank and file labels round a standard diagram
	%   On entry, the ChessFont must be currently selected,
	%   and the (properly scaled) font desired for the labels
	%   must be top of stack.  Uses "cshow", defined above
/dolabels {
	('[<0) show			% position of top-left label
	(0) stringwidth -1.5 div	% 1/3-square offset
	0 exch rmoveto exch		% restore labelfont to top of stack
	[(8)(7)(6)(5)(4)(3)(2)(1)]	% rank labels
	{ gsave exch			% stack == offset, label, labelfont
		dup setfont exch cshow
	  grestore
	  (8;) show			% move down a rank
	} forall
	[(a)(b)(c)(d)(e)(f)(g)(h)]	% file labels
	{ (>) show			% move along a file
	  gsave exch			% as before
		dup setfont exch cshow
	  grestore
	} forall pop			% zap the labelfont
	(0]') show			% move to RHS of board
	1.5 div 0 exch rmoveto		% undo previous offset
} bind def

	% Rotate a piece.  The piece [eg "(Q)"] and the desired rotation
	%   (in degrees, anticlockwise) should be on the stack
/twirl {
	gsave			% keep graphics state
		(0) show	% go to centre of square
		rotate		% no of degrees was on stack
		(07;) show	% back to bottom left of rotated square --
				% "0" takes us from centre to top right, "7"
				% advances 7 squares, ";" goes down one and
				% back 8
		show		% string was on stack
	grestore		% restore graphics state
	( ) show		% advance to next square
} bind def

	% Draw a neutral piece (for Fairy chess).  Expects two strings
	%   [eg. "(R) (r)"] on the stack;  the first will be drawn in
	%   the left half of the square, the second in the right half.
/neutral {
	2 dict begin			% small dictionary for xinc, yinc
	gsave				% keep graphics state
		(0) stringwidth		% distance to centre of square
		/yinc exch 2 mul def
		/xinc exch def
		currentpoint
		xinc 0 rlineto		% draw clipping rectangle round
		0 yinc rlineto		% left half of square
		xinc neg 0 rlineto clip
		moveto show		% show left half-piece
	grestore gsave			% cancel clip
		currentpoint
		xinc 0 rmoveto
		xinc 0 rlineto		% clip right half of square
		0 yinc rlineto
		xinc neg 0 rlineto clip
		moveto show		% show right half-piece
	grestore			% restore graphics state
	( ) show			% advance to next square
	end				% close small dictionary
} bind def

% End of generally useful procedures.

% Quick hack definitions for this file:

% Miscellaneous definitions:

/ps 10.5 def		% point size
/vs 12.5 def		% vertical spacing
/V 11 72 mul def	% top margin
/L 40 def		% left margin

/N { L V vs sub dup /V exch def moveto } bind def	% newline
/T { currentpoint exch L sub 6 add 36 div ceiling 36 mul L add exch moveto }
	bind def	% tab

	% Switch into Chess/Times/Courier/Bold
/C { /ChessFont findfont ps scalefont setfont } bind def
/R { /Times-Roman findfont ps scalefont setfont } bind def
/H { /Courier findfont ps scalefont setfont } bind def
/B { /Times-Bold findfont ps 1.25 mul scalefont setfont } bind def

	12345		% pseudo-random item on stack, as check
